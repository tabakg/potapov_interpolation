

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Potapov_Code package &mdash; Potapov_interpolation 0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Potapov_interpolation 0.1 documentation" href="index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> Potapov_interpolation</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Potapov_interpolation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Potapov_Code package</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/Potapov_Code.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="potapov-code-package">
<h1>Potapov_Code package<a class="headerlink" href="#potapov-code-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-Potapov_Code.Examples">
<span id="potapov-code-examples-module"></span><h2>Potapov_Code.Examples module<a class="headerlink" href="#module-Potapov_Code.Examples" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 17:37:37 2015</p>
<p>&#64;author: gil
&#64;title: examples</p>
<dl class="class">
<dt id="Potapov_Code.Examples.Example1">
<em class="property">class </em><code class="descclassname">Potapov_Code.Examples.</code><code class="descname">Example1</code><span class="sig-paren">(</span><em>max_freq=30.0</em>, <em>max_linewidth=1.0</em>, <em>N=1000</em>, <em>tau=0.3</em>, <em>r=0.8</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Example1" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Examples.Time_Delay_Network" title="Potapov_Code.Examples.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Examples.Time_Delay_Network</span></code></a></p>
<p>Single input, single output with a single delay.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Examples.Example2">
<em class="property">class </em><code class="descclassname">Potapov_Code.Examples.</code><code class="descname">Example2</code><span class="sig-paren">(</span><em>max_freq=10.0</em>, <em>max_linewidth=10.0</em>, <em>N=1000</em>, <em>r=0.9</em>, <em>tau=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Example2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Examples.Time_Delay_Network" title="Potapov_Code.Examples.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Examples.Time_Delay_Network</span></code></a></p>
<p>Two inputs, two outputs with a delay (i.e. Fabry-Perot).</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Examples.Example3">
<em class="property">class </em><code class="descclassname">Potapov_Code.Examples.</code><code class="descname">Example3</code><span class="sig-paren">(</span><em>max_freq=60.0</em>, <em>max_linewidth=1.0</em>, <em>N=5000</em>, <em>r1=0.9</em>, <em>r2=0.4</em>, <em>r3=0.8</em>, <em>tau1=0.1</em>, <em>tau2=0.23</em>, <em>tau3=0.1</em>, <em>tau4=0.17</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Example3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Examples.Time_Delay_Network" title="Potapov_Code.Examples.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Examples.Time_Delay_Network</span></code></a></p>
<p>Two inputs and two outputs, with four delays and third mirror
This corresponds to figures 7 and 8 in our paper.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Examples.Example4">
<em class="property">class </em><code class="descclassname">Potapov_Code.Examples.</code><code class="descname">Example4</code><span class="sig-paren">(</span><em>max_freq=100.0</em>, <em>max_linewidth=3.0</em>, <em>N=5000</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Example4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Examples.Time_Delay_Network" title="Potapov_Code.Examples.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Examples.Time_Delay_Network</span></code></a></p>
<p>Two inputs and two outputs, with free delay (i.e. not in a loop).
This corresponds to figures 9 and 10 in our paper.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Examples.Example5">
<em class="property">class </em><code class="descclassname">Potapov_Code.Examples.</code><code class="descname">Example5</code><span class="sig-paren">(</span><em>max_freq=50.0</em>, <em>max_linewidth=3.0</em>, <em>N=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Example5" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Examples.Time_Delay_Network" title="Potapov_Code.Examples.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Examples.Time_Delay_Network</span></code></a></p>
<p>Modified example 4, with analytic term.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Examples.Time_Delay_Network">
<em class="property">class </em><code class="descclassname">Potapov_Code.Examples.</code><code class="descname">Time_Delay_Network</code><span class="sig-paren">(</span><em>max_freq=30.0</em>, <em>max_linewidth=1.0</em>, <em>N=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to contain the information of a passive linear network with time
delays.</p>
<dl class="attribute">
<dt id="Potapov_Code.Examples.Time_Delay_Network.max_freq">
<code class="descname">max_freq</code><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.max_freq" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [float]</em> &#8211; maximum height in the complex plane</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Examples.Time_Delay_Network.max_linewidth">
<code class="descname">max_linewidth</code><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.max_linewidth" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [float]</em> &#8211; maximum width in the complex plane.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Examples.Time_Delay_Network.N">
<code class="descname">N</code><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.N" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [int]</em> &#8211; number of points to use on the contour for finding</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">the roots/poles of the network.</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Examples.Time_Delay_Network.get_outputs">
<code class="descname">get_outputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.get_outputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Examples.Time_Delay_Network.make_T_Testing">
<code class="descname">make_T_Testing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.make_T_Testing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Examples.Time_Delay_Network.make_roots">
<code class="descname">make_roots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.make_roots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Examples.Time_Delay_Network.make_vecs">
<code class="descname">make_vecs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.make_vecs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Examples.Time_Delay_Network.run_Potapov">
<code class="descname">run_Potapov</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.Time_Delay_Network.run_Potapov" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Examples.example6_pade">
<code class="descclassname">Potapov_Code.Examples.</code><code class="descname">example6_pade</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.example6_pade" title="Permalink to this definition">¶</a></dt>
<dd><p>This example is the same as example 3, but we return a Pade approximation
instead of a Potapov approximation. Instead of returnings roots, etc., we
return a different kind of function (see below).</p>
<p>This is used for figure 14 of our paper.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A matrix-valued function T(z,n). n is the order of the approximation
and z is the location of the function to be evaluated.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Examples.plot3D">
<code class="descclassname">Potapov_Code.Examples.</code><code class="descname">plot3D</code><span class="sig-paren">(</span><em>f</em>, <em>points=2000</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.plot3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a color and hue plot in the complex plane for a given function</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>f (function): to plot
points(optional[int]): number of points to use per dimension</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Examples.plot_all">
<code class="descclassname">Potapov_Code.Examples.</code><code class="descname">plot_all</code><span class="sig-paren">(</span><em>L</em>, <em>dx</em>, <em>labels</em>, <em>colors</em>, <em>lw</em>, <em>name</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Examples.plot_all" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to plot the absolute value and phase of each component for a list
of matrix-valued functions in the complex plane along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; plot from 0 to L</li>
<li><strong>dx</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; distance between points</li>
<li><strong>labels</strong> (<em>list of str</em>) &#8211; labels to use</li>
<li><strong>colors</strong> (<em>list of srt</em>) &#8211; indicators of color for different curves</li>
<li><strong>lw</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; line width to use</li>
<li><strong>name</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the file to save</li>
<li><strong>args</strong> (<em>*</em>) &#8211; A list of functions to plot</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Hamiltonian">
<span id="potapov-code-hamiltonian-module"></span><h2>Potapov_Code.Hamiltonian module<a class="headerlink" href="#module-Potapov_Code.Hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar 31 2015</p>
<p>&#64;author: gil
&#64;title: Hamiltonian.py</p>
<dl class="class">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin">
<em class="property">class </em><code class="descclassname">Potapov_Code.Hamiltonian.</code><code class="descname">Chi_nonlin</code><span class="sig-paren">(</span><em>delay_indices</em>, <em>start_nonlin</em>, <em>length_nonlin</em>, <em>indices_of_refraction</em>, <em>chi_order=3</em>, <em>chi_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to store the information in a particular nonlinear chi element.</p>
<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.delay_indices">
<code class="descname">delay_indices</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.delay_indices" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of indices</em> &#8211; indices of delays to use.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.start_nonlin">
<code class="descname">start_nonlin</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.start_nonlin" title="Permalink to this definition">¶</a></dt>
<dd><p><em>positive float or list of positive floats</em> &#8211; location of
nonlinear crystal with respect to each edge.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.length_nonlin">
<code class="descname">length_nonlin</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.length_nonlin" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; length of the nonlinear element.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.chi_order">
<code class="descname">chi_order</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.chi_order" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [int]</em> &#8211; order of nonlinearity</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.chi_function">
<code class="descname">chi_function</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.chi_function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [function]</em> &#8211; strength of nonlinearity.
first chi_order args are frequencies, next
first chi_order args are frequencies, next chi_order args are
indices of polarization.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian">
<em class="property">class </em><code class="descclassname">Potapov_Code.Hamiltonian.</code><code class="descname">Hamiltonian</code><span class="sig-paren">(</span><em>roots</em>, <em>modes</em>, <em>delays</em>, <em>nonlin_coeff=1.0</em>, <em>polarizations=None</em>, <em>cross_sectional_area=1e-10</em>, <em>chi_nonlinearities=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to create a sympy expression for the Hamiltonian of a network.</p>
<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.roots">
<code class="descname">roots</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.roots" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of complex numbers</em> &#8211; the poles of the transfer function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.omegas">
<code class="descname">omegas</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.omegas" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of floats</em> &#8211; the natural frequencies of the modes.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.modes">
<code class="descname">modes</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.modes" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of complex-valued column matrices</em> &#8211; modes of the network.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.delays">
<code class="descname">delays</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.delays" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of floats</em> &#8211; the delays in the network.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.nonlin_coeff">
<code class="descname">nonlin_coeff</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.nonlin_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [float]</em> &#8211; overall scaling for the nonlinearities.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.polarizations">
<code class="descname">polarizations</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.polarizations" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [list]</em> &#8211; the polarizations of the respective
modes. These should match the arguments in Chi_nonlin.chi_func.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.cross_sectional_area">
<code class="descname">cross_sectional_area</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.cross_sectional_area" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; area of beams, used to determines the</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">scaling for the various modes.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.chi_nonlinearities">
<code class="descname">chi_nonlinearities</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.chi_nonlinearities" title="Permalink to this definition">¶</a></dt>
<dd><p><em>lst</em> &#8211; a list of Chi_nonlin instances.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.E_field_weight">
<code class="descname">E_field_weight</code><span class="sig-paren">(</span><em>mode_index</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.E_field_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the weights for each field component E_i(n) = [weight] (a+a^+)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mode_index</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The index of the mode.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">sqrt[hbar * omega(n) / 2 V_eff(n) epsilon].</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">The weight in the equation above. It has form</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_E_field_weights">
<code class="descname">make_E_field_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_E_field_weights" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dictionary from mode index to the E-field weight.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_H">
<code class="descname">make_H</code><span class="sig-paren">(</span><em>Omega</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a Hamiltonian combining the linear and nonlinear parts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Omega</strong> (<em>complex-valued matrix</em>) &#8211; </li>
<li><strong>= -1j*A        #### full dynamics</strong> (<em>Omega</em>) &#8211; </li>
<li><strong>=</strong> (<em>Omega</em>) &#8211; </li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; Cutoff for the significance of a particular term.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A symbolic expression for the full Hamiltonian.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_chi_nonlinearity">
<code class="descname">make_chi_nonlinearity</code><span class="sig-paren">(</span><em>delay_indices</em>, <em>start_nonlin</em>, <em>length_nonlin</em>, <em>indices_of_refraction</em>, <em>chi_order=3</em>, <em>chi_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_chi_nonlinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an instance of Chi_nonlin to Hamiltonian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>delay_indices</strong> (<em>int OR list/tuple of ints</em>) &#8211; the index representing the</li>
<li><strong>line along which the nonlinearity lies. If given a list/tuple</strong> (<em>delay</em>) &#8211; </li>
<li><strong>the nonlinearity interacts the N different modes.</strong> (<em>then</em>) &#8211; </li>
<li><strong>start_nonlin</strong> (<em>float OR list/tuple of floats</em>) &#8211; the beginning of the</li>
<li><strong>If a list/tuple then each nonlinearity begins at a</strong> (<em>nonlinearity.</em>) &#8211; </li>
<li><strong>time along its corresponding delay line.</strong> (<em>different</em>) &#8211; </li>
<li><strong>length_nonlin</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; duration of the nonlinearity in terms of length.</li>
<li><strong>indices_of_refraction</strong> (<em>float/int or list/tuple of float/int</em>) &#8211; the</li>
<li><strong>of refraction corresponding to the various modes. If float</strong> (<em>indices</em>) &#8211; </li>
<li><strong>int then all are the same.</strong> (<em>or</em>) &#8211; </li>
<li><strong>chi_order</strong> (<em>optional [int]</em>) &#8211; order of the chi nonlinearity.</li>
<li><strong>chi_function</strong> (<em>function</em>) &#8211; a function of 2*(chi_order+1) parameters that</li>
<li><strong>the strenght of the interaction for given frequency</strong> (<em>returns</em>) &#8211; </li>
<li><strong>and polarizations.</strong> (<em>combinations</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_eq_motion">
<code class="descname">make_eq_motion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_eq_motion" title="Permalink to this definition">¶</a></dt>
<dd><p>Input is a tuple or list, output is a matrix vector.
This generates Hamilton&#8217;s equations of motion for a and a^H.
These equations are CLASSICAL equations of motion. This means
we replace the operators with c-numbers. The order of the operators
will yield different results, so we assume the Hamiltonian is already
in the desired order (e.g. normally ordered).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A function that yields the Hamiltonian equations of motion based on
the Hamiltonian given.
The equations of motion take an array as an input and return a column
vector as an output.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_lin_H">
<code class="descname">make_lin_H</code><span class="sig-paren">(</span><em>Omega</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_lin_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a linear Hamiltonian based on Omega.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Omega</strong> (<em>complex-valued matrix</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A symbolic expression for the nonlinear Hamiltonian.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_H_from_chi">
<code class="descname">make_nonlin_H_from_chi</code><span class="sig-paren">(</span><em>chi</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_H_from_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nonlinear Hamiltonian based on nonlinear interaction terms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chi</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Potapov_Code.Hamiltonian.Chi_nonlin"><em>Chi_nonlin</em></a>) &#8211; nonlinearity to use</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; Cutoff for the significance of a particular term.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A symbolic expression for the nonlinear Hamiltonian.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>TODO: Further restrict terms iterated over to make the RWA (i.e.</dt>
<dd>frequency-match terms).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_term_sympy">
<code class="descname">make_nonlin_term_sympy</code><span class="sig-paren">(</span><em>combination</em>, <em>pm_arr</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_term_sympy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make symbolic nonlinear term using sympy.</p>
<p>Example:
&gt;&gt;&gt; combination = [1,2,3]; pm_arr = [-1,1,1]
&gt;&gt;&gt; print Hamiltonian.make_nonlin_term_sympy(combination,pm_arr)
self.a(1) * Dagger(self.a(2)) * Dagger(self.a(3))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>combination</strong> (<em>tuple/list of integers</em>) &#8211; indices of which terms to
include pm_arr (tuple/list of +1 and -1): creation and
annihilation indicators for the respective terms in combination.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">symbolic expression for the combination of creation and annihilation
operators.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_phase_matching_weights">
<code class="descname">make_phase_matching_weights</code><span class="sig-paren">(</span><em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_phase_matching_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dict to store the weights for the selected components and the
creation/annihilation information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chi</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Potapov_Code.Hamiltonian.Chi_nonlin"><em>Chi_nonlin</em></a>) &#8211; the chi nonlinearity for which to compute
the phase coefficient.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dictionary of weights. Each key is a tuple consisting of two
components: the first is a tuple of the indices of modes and the
second is a tuple of +1 and -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.mode_volumes">
<code class="descname">mode_volumes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.mode_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the effective volume of each mode to normalize the field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the effective lengths of the various modes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.normalize_modes">
<code class="descname">normalize_modes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.normalize_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the modes of Hamiltonian.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.phase_weight">
<code class="descname">phase_weight</code><span class="sig-paren">(</span><em>combination</em>, <em>pm_arr</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.phase_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>The weight to give to each nonlinear term characterized by the given
combination and pm_arr.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>combination</strong> (<em>list/tuple of integers</em>) &#8211; which modes/roots to pick</li>
<li><strong>pm_arr</strong> (<em>list of +1 and -1</em>) &#8211; creation and annihilation of modes</li>
<li><strong>chi</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Potapov_Code.Hamiltonian.Chi_nonlin"><em>Chi_nonlin</em></a>) &#8211; the chi nonlinearity for which to compute
the phase coefficient.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The weight to add to the Hamiltonian</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Potapov">
<span id="potapov-code-potapov-module"></span><h2>Potapov_Code.Potapov module<a class="headerlink" href="#module-Potapov_Code.Potapov" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 13:59:30 2015</p>
<p>&#64;author: Gil Tabak
&#64;title: Potapov</p>
<p>The code in this file implements the procedure for finding Blaschke-Potapov
products to approximate given functions near poles.</p>
<p>Please see section 6.2 in our manuscript for details: <a class="reference external" href="http://arxiv.org/abs/1510.08942">http://arxiv.org/abs/1510.08942</a>
(to be published in EPJ QT).</p>
<dl class="function">
<dt id="Potapov_Code.Potapov.Potapov_prod">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">Potapov_prod</code><span class="sig-paren">(</span><em>z</em>, <em>poles</em>, <em>vecs</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.Potapov_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a transfer function T(z) that outputs numpy matrices for imaginary
z = i omega and the desired poles that characterize the modes.
Returns the Potapov product as a function approximating the original
transfer function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>complex number</em>) &#8211; value where product is evaluated</li>
<li><strong>poles</strong> (<em>list of complex numbers</em>) &#8211; The poles of the Potapov product.</li>
<li><strong>vecs</strong> (<em>list of complex-valued matrices</em>) &#8211; The eigenvectors corresponding to</li>
<li><strong>orthogonal projectors of the Potapov product.</strong> (<em>the</em>) &#8211; </li>
<li><strong>N</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Dimensionality of the the range.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Complex-valued matrix of size N-by-N.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.estimate_D">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">estimate_D</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>C</em>, <em>T</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.estimate_D" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the scattering matrix S=D using the ABC matrices
the transfer function T at a frequency z = i omega.</p>
<p>Try to satisfy
T(z) = D + C(zI-A)^{-1}B</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A,B,C</strong> (<em>matrices</em>) &#8211; The A,B, and C matrices of the</li>
<li><strong>representation</strong> (<em>state-space</em>) &#8211; </li>
<li><strong>T</strong> (<em>matrix-valued function</em>) &#8211; The input/output function</li>
<li><strong>estimate</strong> (<em>to</em>) &#8211; </li>
<li><strong>z</strong> (<em>complex number</em>) &#8211; the location at which the scattering</li>
<li><strong>will be estimated</strong> (<em>matrix</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The estimated S=D scaterring matrix based on the value of
the function T and the ABC matrices.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.finite_transfer_function">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">finite_transfer_function</code><span class="sig-paren">(</span><em>U</em>, <em>eigenvectors</em>, <em>eigenvalues</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.finite_transfer_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a rational Blaschke-Potapov product of z with the given
eigenvalues and eigenvectors and constant unitary factor U.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>complex-valued matrix</em>) &#8211; A unitary matrix.</li>
<li><strong>eigenvectors</strong> (<em>list of complex-valued matrices</em>) &#8211; eigenvectors to use</li>
<li><strong>eigenvalues</strong> (<em>list of complex numebrs</em>) &#8211; eigenvalues to use</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A function that takes a complex number and returns the Potapov product
evaluated at that number.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_ABCD">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_ABCD</code><span class="sig-paren">(</span><em>val</em>, <em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_ABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the ABCD model of a single Potapov factor given some eigenvalue
and eigenvector.</p>
<p>The ABCD model can be used to obtain the dynamics of a linear system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> (<em>complex number</em>) &#8211; an eigenvalue</li>
<li><strong>vec</strong> (<em>complex-valued matrix</em>) &#8211; an eigenvector</li>
<li><strong>sym</strong> (<em>optiona[boolean]</em>) &#8211; Modify B and C so that B = C.H</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list [A,B,C,D] of four matrices representing the ABCD model.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_Potapov">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_Potapov</code><span class="sig-paren">(</span><em>T</em>, <em>poles</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_Potapov" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a transfer function T and some poles, generate the Blaschke-Potapov
product to reconstruct or approximate T, assuming that T can be represented
by the Blaschke-Potapov product with the given poles. Also match the values
of the functions at zero.</p>
<p>If T is a Blaschke-Potapov function and the the given poles are the only poles,
then T will be reconstructed.</p>
<p>In general, there is possibly an analytic term that is not captured by using
a Blaschke-Potapov approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>T</strong> (<em>matrix-valued function</em>) &#8211; A given meromorphic function</li>
<li><strong>poles</strong> (<em>a list of complex valued numbers</em>) &#8211; The given poles of T</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A matrix-valued function equation to T at z=0 and approximating T
using a Potapov product generated by its poles and residues.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_Potapov_ABCD">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_Potapov_ABCD</code><span class="sig-paren">(</span><em>poles</em>, <em>vecs</em>, <em>T=None</em>, <em>z=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_Potapov_ABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the ABCD models for the different degrees of freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> (<em>a list of complex numbers</em>) &#8211; given eigenvalues</li>
<li><strong>vec</strong> (<em>a list of complex-valued matrices</em>) &#8211; given eigenvectors</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list [A,B,C,D] of four matrices representing the ABCD model.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_Potapov_vecs">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_Potapov_vecs</code><span class="sig-paren">(</span><em>T</em>, <em>poles</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_Potapov_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a transfer function T and some poles, compute the residues about the
poles and generate the eigenvectors to use for constructing the projectors
in the Blaschke-Potapov factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.normalize">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">normalize</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize a vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> (<em>complex-valued matrix</em>) &#8211; a vector</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The normalized vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.plot">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>L</em>, <em>dx</em>, <em>func</em>, <em>(i</em>, <em>j)</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>A nice function for plotting components of matrix-valued functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>L</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; length along which to plot</li>
<li><strong>dx</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; step length to take</li>
<li><strong>func</strong> (<em>function</em>) &#8211; complex matrix-valued function</li>
<li><strong>(i,j)</strong> (<em>tuple of ints</em>) &#8211; coordinate to plot</li>
<li><strong>*args</strong> (<a class="reference internal" href="#module-Potapov_Code.functions" title="Potapov_Code.functions"><em>functions</em></a>) &#8211; Desired transformations on the inputs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.prod">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">prod</code><span class="sig-paren">(</span><em>z</em>, <em>U</em>, <em>eigenvectors</em>, <em>eigenvalues</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Blaschke-Potapov product with the given eigenvalues and
eigenvectors and constant unitary factor U evaluated at z.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>complex number</em>) &#8211; where product is evaluated</li>
<li><strong>U</strong> (<em>complex-valued matrix</em>) &#8211; A unitary matrix</li>
<li><strong>eigenvectors</strong> (<em>list of complex-valued matrices</em>) &#8211; eigenvectors to use</li>
<li><strong>eigenvalues</strong> (<em>list of complex numebrs</em>) &#8211; eigenvalues to use</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A complex-valued matrix equal to the Potapov product evaluated at z.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Roots">
<span id="potapov-code-roots-module"></span><h2>Potapov_Code.Roots module<a class="headerlink" href="#module-Potapov_Code.Roots" title="Permalink to this headline">¶</a></h2>
<p>Created on Sat Feb 28 20:15:35 2015</p>
<p>&#64;author: gil
&#64;title: Rootfinder</p>
<p>Find the roots of a function f in the complex plane inside of a rectangular region.
We implement the method in the following paper:</p>
<blockquote>
<div>Delves, L. M., and J. N. Lyness. &#8220;A numerical method for locating the zeros of
an analytic function.&#8221; Mathematics of computation 21.100 (1967): 543-560.</div></blockquote>
<p>The main idea is to compute contour integrals of functions of the form
$z^k fp/f$ around the contour, for integer values of k. Here fp denotes the
derivative of f. The resulting values of the contour integrals are proportional
to $sum_i z_i^k$, where i is the index of the roots.</p>
<p>Throughout we denote f_frac = fp/f.</p>
<p>I have also tried several optimizations and strategies for numerical stability.</p>
<dl class="function">
<dt id="Potapov_Code.Roots.Muller">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">Muller</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>x3</em>, <em>f</em>, <em>tol=1e-12</em>, <em>N=400</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.Muller" title="Permalink to this definition">¶</a></dt>
<dd><p>A method that works well for finding roots locally in the complex plane.
Uses three points for initial guess, x1,x2,x3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x1,x2,x3</strong> (<em>complex numbers</em>) &#8211; initial points for the algorithm</li>
<li><strong>f</strong> (<em>function</em>) &#8211; complex valued function for which to find roots</li>
<li><strong>tol</strong> (<em>optional[float]</em>) &#8211; tolerance</li>
<li><strong>N</strong> (<em>optional[int]</em>) &#8211; maximum number of iterations</li>
<li><strong>verbose</strong> (<em>optional[boolean]</em>) &#8211; print warnings</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">estimated root of the function f.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.combine">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">combine</code><span class="sig-paren">(</span><em>eps=1e-05</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>chain together several lists and purge redundancies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; tolerance for purging elements</li>
<li><strong>*args</strong> (<em>lists</em>) &#8211; several lists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of combined elements.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.find_maxes">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">find_maxes</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.find_maxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of numbers, find the indices where local maxima happen.</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>y(list of floats)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of indices where maxima occur</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.find_roots">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">find_roots</code><span class="sig-paren">(</span><em>y_smooth</em>, <em>c</em>, <em>num_roots_to_find</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.find_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>given the values y_smooth, locations c, and the number to go up to,
find the roots using the polynomial trick.</p>
<dl class="docutils">
<dt>Given:</dt>
<dd>y_smooth (list of complex numbers)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.get_boundary">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">get_boundary</code><span class="sig-paren">(</span><em>x_cent</em>, <em>y_cent</em>, <em>width</em>, <em>height</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.get_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a rectangle centered at x_cent,y_cent. Find points along this rectangle.
I use the convention that width/height make up half the dimensions of the rectangle.</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>x_cent,y_cent (floats): the coordinates of the center of the rectangle
width,height (float): The (half) width and height of the rectangle
N (int): number of points to use along each edge.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of points along the edge of the rectangle in the complex plane.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.get_max">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">get_max</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.get_max" title="Permalink to this definition">¶</a></dt>
<dd><p>return the IQR + median to determine a maximum permissible value to use
in the numerically safe function new_f_frac_safe.</p>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.get_roots_rect">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">get_roots_rect</code><span class="sig-paren">(</span><em>f</em>, <em>fp</em>, <em>x_cent</em>, <em>y_cent</em>, <em>width</em>, <em>height</em>, <em>N=10</em>, <em>outlier_coeff=100.0</em>, <em>max_steps=5</em>, <em>known_roots=[]</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.get_roots_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>I assume f is analytic with simple (i.e. order one) zeros.</p>
<p>TODO:
save values along edges if iterating to a smaller rectangle
extend to other kinds of functions, e.g. function with non-simple zeros.</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>f (function): the function for which the roots (i.e. zeros) will be found
fp (function): the derivative of f
x_cent,y_cent (floats): The center of the rectangle in the complex plane
width,height (floats): half the width and height of the rectangular region
N (optional[int]): Number of points to sample per edge
outlier_coeff (float): multiplier for coefficient used when subtracting
poles to improve numerical stability. See new_f_frac_safe.
max_step (optional[int]): Number of iterations allowed for algorithm to
repeat on smaller rectangles
known roots (optional[list of complex numbers]): Roots of f that are
already known.
verbose (optional[boolean]): print warnings</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of roots for the function f inside the rectangle determined by
the values x_cent,y_cent,width, and height.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.inside_boundary">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">inside_boundary</code><span class="sig-paren">(</span><em>roots_near_boundary</em>, <em>x_cent</em>, <em>y_cent</em>, <em>width</em>, <em>height</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.inside_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes roots and the specification of a rectangular region
returns the roots in the interior (and ON the boundary) of the region.</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>roots_near_boundary (list of complex numbers): roots near the boundary
x_cent,y_cent (floats): coordinates of the center of the region
width,height (floats): The (half) width of height of the rectangle</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Roots in the interior and on the boundary of the rectangle</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.linspace">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">linspace</code><span class="sig-paren">(</span><em>c1</em>, <em>c2</em>, <em>num=50</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>make a linespace method for complex numbers.</p>
<dl class="docutils">
<dt>Given:</dt>
<dd>c1,c2 (complex numbers): The two points along which to draw a line.
num (optional [int]): number of points along the line</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of num points starting at c1 and going to c2.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.new_f_frac">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">new_f_frac</code><span class="sig-paren">(</span><em>f_frac</em>, <em>z0</em>, <em>residues</em>, <em>roots</em>, <em>val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.new_f_frac" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions that evaluate the f_frac after some roots and their residues are subtracted.
This function does NOT check to see if there is division by zero of if the
values become too large.</p>
<p>We assume here that the poles are of order 1.</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>f_frac (function): function for which roots will be subtracted
z0 (complex number): point where new_f_frac is evaluated
residues (list of complex numbers): The corresponding residues to subtract
roots (list of complex numbers): The corresponding roots to subtract
val (optional[complex number]): We can impose a value f_frac(z0) if we wish.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The new value of f_frac(z0) once the chosen poles have been subtracted.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.new_f_frac_safe">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">new_f_frac_safe</code><span class="sig-paren">(</span><em>f_frac</em>, <em>z0</em>, <em>residues</em>, <em>roots</em>, <em>max_ok</em>, <em>val=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.new_f_frac_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions that evaluate the f_frac after some roots and their residues are subtracted.
The safe version checks for large values and division by zero.
If the value of f_frac(z0) is too large, subtracting the roots of f becomes
numerically unstable. In this case, we approximate the new function f_frac
by using the limit function.</p>
<p>We assume here that the poles are of order 1.</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>f_frac (function): function for which roots will be subtracted
z0 (complex number): point where new_f_frac is evaluated
residues (list of complex numbers): The corresponding residues to subtract
roots (list of complex numbers): The corresponding roots to subtract
val (optional[complex number]): We can impose a value f_frac(z0) if we wish.
max_ok (float) Maximum absolute value of f_frac(z0 to use)
verbose (optional[boolean]): print warnings</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The new value of f_frac(z0) once the chosen poles have been subtracted.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.purge">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">purge</code><span class="sig-paren">(</span><em>lst</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.purge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of redundant elements in a list. There is a precision cutoff eps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lst</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; elements</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; precision cutoff</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list without redundant elements.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.residues">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">residues</code><span class="sig-paren">(</span><em>f_frac</em>, <em>roots</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.residues" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the resides of f_frac = fp/f given the location of some roots of f.
The roots of f are the poles of f_frac.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f_frac</strong> (<em>function</em>) &#8211; a complex</li>
<li><strong>roots</strong> (<em>a list of complex numbers</em>) &#8211; the roots of f; poles of f_frac</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of residues of f_frac.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Time_Sims">
<span id="potapov-code-time-sims-module"></span><h2>Potapov_Code.Time_Sims module<a class="headerlink" href="#module-Potapov_Code.Time_Sims" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 15:52:32 2015</p>
<p>&#64;author: gil
&#64;title: Time_Sims</p>
<dl class="function">
<dt id="Potapov_Code.Time_Sims.f">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">f</code><span class="sig-paren">(</span><em>t</em>, <em>y</em>, <em>A</em>, <em>B</em>, <em>force_func</em>, <em>forcing_port</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.plot_time">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">plot_time</code><span class="sig-paren">(</span><em>time</em>, <em>y</em>, <em>port_out</em>, <em>port_in</em>, <em>num=0</em>, <em>kind='FP'</em>, <em>format='pdf'</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.plot_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.stack_func_port">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">stack_func_port</code><span class="sig-paren">(</span><em>force_func</em>, <em>forcing_port</em>, <em>t</em>, <em>max_size</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.stack_func_port" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.test_stacking">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">test_stacking</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.test_stacking" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.time_sim">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">time_sim</code><span class="sig-paren">(</span><em>Example, omega=0.0, t1=150, dt=0.05, freq=None, port_in=0, port_out=[0, 1], kind='FP'</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.time_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>takes an example and simulates it up to t1 increments of dt.
freq indicates the maximum frequency where we look for modes
omega indicates the frequency of driving. omega = 0 is DC.
port_in and port_out are where the system is driven.</p>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Time_Sims_nonlin">
<span id="potapov-code-time-sims-nonlin-module"></span><h2>Potapov_Code.Time_Sims_nonlin module<a class="headerlink" href="#module-Potapov_Code.Time_Sims_nonlin" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar 31 2015</p>
<p>&#64;author: gil
&#64;title: Time_Sims_Nonlin.py</p>
<dl class="function">
<dt id="Potapov_Code.Time_Sims_nonlin.double_up">
<code class="descclassname">Potapov_Code.Time_Sims_nonlin.</code><code class="descname">double_up</code><span class="sig-paren">(</span><em>M1</em>, <em>M2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims_nonlin.double_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a given matrix M1 and an optional matrix M2 and generates a
doubled-up matrix to use for simulations when the doubled-up notation
is needed. i.e.</p>
<div class="math">
\[\begin{split}\begin{pmatrix}
    M_1 &amp;&amp; M_2
\end{pmatrix}
\to
\begin{pmatrix}
    M_1 &amp;&amp; M_2 \\
    M_2^\# &amp;&amp; M_1^\#
\end{pmatrix}\end{split}\]</div>
<p>In the case M2 == None, it becomes replaced by the zero matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M1</strong> &#8211; matrix to double-up</li>
<li><strong>M2</strong> &#8211; optional second matrix to double-up</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The doubled-up matrix.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims_nonlin.make_f">
<code class="descclassname">Potapov_Code.Time_Sims_nonlin.</code><code class="descname">make_f</code><span class="sig-paren">(</span><em>eq_mot</em>, <em>B</em>, <em>a_in</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims_nonlin.make_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations of motion, including possibly nonlinear internal dynamics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>eq_mot</strong> (<em>function</em>) &#8211; The equations of motion, which take an array and return a
matrix column.</li>
<li><strong>B</strong> (<em>matrix</em>) &#8211; The matrix multiplying the inputs to the system.</li>
<li><strong>a_in</strong> (<em>function</em>) &#8211; The inputs to the system</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A function that maps (t,a) -&gt; f&#8217;(t,a), where t is a scalar (time), and
a is an array representing the state of the system.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims_nonlin.make_f_lin">
<code class="descclassname">Potapov_Code.Time_Sims_nonlin.</code><code class="descname">make_f_lin</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>a_in</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims_nonlin.make_f_lin" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear equations of motion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>matrix</em>) &#8211; The matrix for the linear equations of motion:
<span class="math">\(\frac{d}{dt}\begin{pmatrix} a \\ a^+ \end{pmatrix} = A \begin{pmatrix} a \\ a^+ \end{pmatrix}+ B \breve a_{in} (t).\)</span></li>
<li><strong>B</strong> (<em>matrix</em>) &#8211; The matrix multiplying the inputs to the system.</li>
<li><strong>a_in</strong> (<em>function</em>) &#8211; The inputs to the system <span class="math">\(\breve a\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A function that maps (t,a) -&gt; f&#8217;(t,a), where t is a scalar (time), and
a is an array representing the state of the system.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims_nonlin.run_ODE">
<code class="descclassname">Potapov_Code.Time_Sims_nonlin.</code><code class="descname">run_ODE</code><span class="sig-paren">(</span><em>f</em>, <em>a_in</em>, <em>C</em>, <em>D</em>, <em>num_of_variables</em>, <em>T=100</em>, <em>dt=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims_nonlin.run_ODE" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the ODE for the given set of equations and record the outputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> (<em>function</em>) &#8211; Evolution of the system</li>
<li><strong>a_in</strong> (<em>function</em>) &#8211; inputs as a function of time</li>
<li><strong>C,D</strong> (<em>matrices</em>) &#8211; matrices to use to obtain output from system state and input</li>
<li><strong>num_of_variables</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of variables the system has</li>
<li><strong>T</strong> (<em>optional[positive float]</em>) &#8211; length of simulation</li>
<li><strong>dt</strong> (<em>optional[float]</em>) &#8211; time step used by the simulation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array Y of outputs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.functions">
<span id="potapov-code-functions-module"></span><h2>Potapov_Code.functions module<a class="headerlink" href="#module-Potapov_Code.functions" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 13:59:30 2015</p>
<p>&#64;author: Gil Tabak
&#64;title: Potapov</p>
<p>Functions used by other files.</p>
<dl class="function">
<dt id="Potapov_Code.functions.Pade">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">Pade</code><span class="sig-paren">(</span><em>n</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.Pade" title="Permalink to this definition">¶</a></dt>
<dd><p>Pade pproximation of e^z</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>integer</em>) &#8211; order of approximation</li>
<li><strong>z</strong> (<em>complex number</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Value of Pade approximation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.Q">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">Q</code><span class="sig-paren">(</span><em>z</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerator of Pade pproximation of e^z</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>integer</em>) &#8211; order of approximation</li>
<li><strong>z</strong> (<em>complex number</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Value of Numerator of Pade approximation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.der">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">der</code><span class="sig-paren">(</span><em>f</em>, <em>z</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.der" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the derivative of the function f at z</p>
<dl class="docutils">
<dt>Given:</dt>
<dd>f (function): the function to use
z (complex number): point to evaluate
eps(optional[complex number]): number to perturb z to find derivative</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Derivative of f</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.factorial">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">factorial</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the factorial of n.
:param n:
:type n: integer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">factorial of n</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.inner_product_of_two_modes">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">inner_product_of_two_modes</code><span class="sig-paren">(</span><em>root1</em>, <em>root2</em>, <em>v1</em>, <em>v2</em>, <em>delays</em>, <em>eps=1e-07</em>, <em>func=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.inner_product_of_two_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>This function integrates two spatial modes against each other
along the various delays of the system. Each delay follows a
node in the system.</p>
<p>The frequency is assumed to be the imaginary part of each root.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>root1,root2</strong> (<em>complex number</em>) &#8211; the two roots</li>
<li><strong>v1,v2</strong> (<em>column matrices</em>) &#8211; the amplitude of each mode at the</li>
<li><strong>nodes</strong> (<em>various</em>) &#8211; </li>
<li><strong>delays</strong> (<em>list of floats</em>) &#8211; The duration of each delay following</li>
<li><strong>node in the system</strong> (<em>each</em>) &#8211; </li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; cutoff for two frequencies being equal</li>
<li><strong>func</strong> (<em>optional[funciton]</em>) &#8211; used to transform the roots. Default</li>
<li><strong>is set to lambda z</strong> (<em>value</em>) &#8211; z.imag, meaning we take the frequency</li>
<li><strong>each mode.</strong> (<em>of</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The inner product of the two modes.
Sanity check: if root1==root2 and v1==v2, returns real value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.limit">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">limit</code><span class="sig-paren">(</span><em>f</em>, <em>z0</em>, <em>N=10</em>, <em>eps=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes possibly matrix-valued function f and its simple pole z0 and returns
limit_{z    o val} f(z). Estimates the value based on N surrounding
points at a distance eps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> (<em>function</em>) &#8211; the function for which the limit will be found.</li>
<li><strong>z0</strong> (<em>complex number</em>) &#8211; The value at which the limit is evaluated.</li>
<li><strong>N</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of points used in the estimate.</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; distance from z0 at which estimating points are</li>
<li><strong>placed.</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The estimated value of limit_{z        o val} f(z).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.make_nonlinear_interaction">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">make_nonlinear_interaction</code><span class="sig-paren">(</span><em>natural_freqs</em>, <em>modes</em>, <em>delays</em>, <em>delay_indices</em>, <em>start_nonlin</em>, <em>length_nonlin</em>, <em>plus_or_minus_arr</em>, <em>indices_of_refraction=None</em>, <em>eps=1e-12</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.make_nonlinear_interaction" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes several (say M) natural_freqs and their corresponding modes,
as well as the (N) delay lengths of the network, and determines the term
we need to add to the Hamiltonian corresponding to the resulting
nonlinearity. We assume there is a crystal going from start_nonlin to
and has length length_nonlin. The plus_or_minus_arr is an array of
length m of 1 or -1 used to determined whether a mode corresponds to a
creation (1, a^dag) or annihilation (-1,a) operator. The corresponding
electric field integrated will be E^dag for 1 and E for -1.</p>
<p>The k-vectors are computed from the following formula:
k = omega / v_p = omega n(omega) / c.</p>
<p>Below we assume c == 1. We can modify the frequencies or n&#8217;s to make the
units work.</p>
<p>If the indices of refraction n(omega_i) are given, we use them to compute
the phase-mismatch delta_k. Otherwise we assume they are all equal to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>natural_freqs</strong> (<em>list of complex numbers</em>) &#8211; The natural frequencies of the
various eigenmodes</li>
<li><strong>modes</strong> (<em>list of column matrices</em>) &#8211; the amplitudes of the modes at
various nodes</li>
<li><strong>delays</strong> (<em>list of floats</em>) &#8211; The duration of each delay following
each node in the system</li>
<li><strong>delay_indices</strong> (<em>int OR list/tuple of ints</em>) &#8211; the index representing the
delay line along which the nonlinearity lies. If given a list/tuple
then the nonlinearity interacts the N different modes.</li>
<li><strong>start_nonlin</strong> (<em>float OR list/tuple of floats</em>) &#8211; the beginning of the
nonlinearity. If a list/tuple then each nonlinearity begins at a
different time along its corresponding delay line.</li>
<li><strong>length_nonlin</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; duration of the nonlinearity in terms of length.</li>
<li><strong>plus_or_minus_arr</strong> (<em>array of 1s and -1s</em>) &#8211; Creation/annihilation of
a photon in each of the given modes</li>
<li><strong>indices_of_refraction</strong> (<em>float/int or list/tuple of float/int</em>) &#8211; the
indices of refraction corresponding to the various modes. If float
or int then all are the same.</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; cutoff for two frequencies being equal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A matrix of normalized inner products representing the geometric
overlap of the various given modes in the system.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.make_normalized_inner_product_matrix">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">make_normalized_inner_product_matrix</code><span class="sig-paren">(</span><em>roots</em>, <em>modes</em>, <em>delays</em>, <em>eps=1e-12</em>, <em>func=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.make_normalized_inner_product_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of roots and a list of vectors representing the
electric field at each node of the corresponding nodes, compute
the normalized matrix representing the inner products among the
various modes.</p>
<p>TODO: add weights for different delays to account for geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roots</strong> (<em>list of complex numbers</em>) &#8211; The roots of the various eigenmodes</li>
<li><strong>modes</strong> (<em>list of column matrices</em>) &#8211; the amplitudes of the modes at</li>
<li><strong>nodes</strong> (<em>various</em>) &#8211; </li>
<li><strong>delays</strong> (<em>list of floats</em>) &#8211; The duration of each delay following</li>
<li><strong>node in the system</strong> (<em>each</em>) &#8211; </li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; cutoff for two frequencies being equal</li>
<li><strong>func</strong> (<em>optional[funciton]</em>) &#8211; used to transform the roots. Default</li>
<li><strong>is set to lambda z</strong> (<em>value</em>) &#8211; z.imag, meaning we take the frequency</li>
<li><strong>each mode.</strong> (<em>of</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A matrix of normalized inner products representing the geometric
overlap of the various given modes in the system.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.pade_approx">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">pade_approx</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.pade_approx" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>integer</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Denominator of symmetric Pade approximation of e^{-s} of order n</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.pade_roots">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">pade_roots</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.pade_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract roots of Pade polynomial.
:param n:
:type n: integer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Roots of Pade polynomial.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.spatial_modes">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">spatial_modes</code><span class="sig-paren">(</span><em>roots</em>, <em>M1</em>, <em>E</em>, <em>delays=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.spatial_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the spetial mode profile at each node up to a constant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roots</strong> &#8211; The eigenvalues of the system</li>
<li><strong>M1</strong> (<em>matrix</em>) &#8211; The connectivity matrix among internal nodes</li>
<li><strong>E</strong> (<em>matrix-valued function</em>) &#8211; Time-delay matrix</li>
<li><strong>delays</strong> (<em>optional[list of floats]</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of spatial eigenvectors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.tests">
<span id="potapov-code-tests-module"></span><h2>Potapov_Code.tests module<a class="headerlink" href="#module-Potapov_Code.tests" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Potapov_Code.tests.test_Hamiltonian">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_Hamiltonian</code><span class="sig-paren">(</span><em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_Hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>This method tests various methods in Hamiltonian and Time_Sims_nonlin.
In particular, we compare the output from the classical equations of motion
that results directly from the ABCD model versus the classical Hamiltonian
equations of motion when we set the coefficient of the nonlinearity to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>eps[optional</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; how closely each point in time along the two</li>
<li><strong>trajectories should match.</strong> (<em>tested</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.test_Potapov_1">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_Potapov_1</code><span class="sig-paren">(</span><em>eps=1e-07</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_Potapov_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a finite_transfer_function from eigenvectors and eigenvalues.
Then generate a Potapov product from the finite transfer function. These
should be analytically equal. We test to see if they are close within some
precision.</p>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.test_Roots_1">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_Roots_1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_Roots_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a square of length just under 5*pi. Find the roots of sine.</p>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.test_Roots_2">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_Roots_2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_Roots_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a square of length just over 5*pi. Find the roots of sine.</p>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.test_example_1">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_example_1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_example_1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.test_example_2">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_example_2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_example_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.test_example_3">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_example_3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_example_3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.test_example_4">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_example_4</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_example_4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.tests.two_sets_almost_equal">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">two_sets_almost_equal</code><span class="sig-paren">(</span><em>S1</em>, <em>S2</em>, <em>eps=1e-07</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.two_sets_almost_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if two iterables have the same elements up to some tolerance eps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>S1,S2</strong> (<em>lists</em>) &#8211; two lists</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; precision for testing each elements</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if the two sets are equal up to eps, false otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-Potapov_Code" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Potapov_Code.contour_plot">
<code class="descclassname">Potapov_Code.</code><code class="descname">contour_plot</code><span class="sig-paren">(</span><em>Mat</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.contour_plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Gil Tabak.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>