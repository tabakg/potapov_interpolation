

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Potapov_Code package &mdash; Potapov_interpolation 0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Potapov_interpolation 0.1 documentation" href="index.html"/>
        <link rel="prev" title="Readme" href="includeme.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> Potapov_interpolation</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="includeme.html">Readme</a><ul>
<li class="toctree-l2"><a class="reference internal" href="includeme.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="includeme.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="includeme.html#files">Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="includeme.html#sample-usage-time-domain-simulation">Sample Usage &#8211; Time Domain Simulation</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Potapov_Code package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.Time_Delay_Network">Potapov_Code.Time_Delay_Network module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.Hamiltonian">Potapov_Code.Hamiltonian module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.Potapov">Potapov_Code.Potapov module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.Roots">Potapov_Code.Roots module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.Time_Sims">Potapov_Code.Time_Sims module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.Time_Sims_nonlin">Potapov_Code.Time_Sims_nonlin module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.functions">Potapov_Code.functions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code.tests">Potapov_Code.tests module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Potapov_Code">Module contents</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Potapov_interpolation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Potapov_Code package</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/Potapov_Code.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="potapov-code-package">
<h1>Potapov_Code package<a class="headerlink" href="#potapov-code-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-Potapov_Code.Time_Delay_Network">
<span id="potapov-code-time-delay-network-module"></span><h2>Potapov_Code.Time_Delay_Network module<a class="headerlink" href="#module-Potapov_Code.Time_Delay_Network" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 17:37:37 2015</p>
<p>&#64;author: gil
&#64;title: examples</p>
<dl class="class">
<dt id="Potapov_Code.Time_Delay_Network.Example1">
<em class="property">class </em><code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">Example1</code><span class="sig-paren">(</span><em>max_freq=30.0</em>, <em>max_linewidth=1.0</em>, <em>N=1000</em>, <em>center_freq=0.0</em>, <em>tau=0.3</em>, <em>r=0.8</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Example1" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network" title="Potapov_Code.Time_Delay_Network.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Time_Delay_Network.Time_Delay_Network</span></code></a></p>
<p>Single input, single output with a single delay.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Time_Delay_Network.Example2">
<em class="property">class </em><code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">Example2</code><span class="sig-paren">(</span><em>max_freq=10.0</em>, <em>max_linewidth=10.0</em>, <em>N=1000</em>, <em>center_freq=0.0</em>, <em>r=0.9</em>, <em>tau=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Example2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network" title="Potapov_Code.Time_Delay_Network.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Time_Delay_Network.Time_Delay_Network</span></code></a></p>
<p>Two inputs, two outputs with a delay (i.e. Fabry-Perot).</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Time_Delay_Network.Example3">
<em class="property">class </em><code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">Example3</code><span class="sig-paren">(</span><em>max_freq=60.0</em>, <em>max_linewidth=1.0</em>, <em>N=5000</em>, <em>center_freq=0.0</em>, <em>r1=0.9</em>, <em>r2=0.4</em>, <em>r3=0.8</em>, <em>tau1=0.1</em>, <em>tau2=0.23</em>, <em>tau3=0.1</em>, <em>tau4=0.17</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Example3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network" title="Potapov_Code.Time_Delay_Network.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Time_Delay_Network.Time_Delay_Network</span></code></a></p>
<p>Two inputs and two outputs, with four delays and third mirror
This corresponds to figures 7 and 8 in our paper.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Time_Delay_Network.Example4">
<em class="property">class </em><code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">Example4</code><span class="sig-paren">(</span><em>max_freq=100.0</em>, <em>max_linewidth=3.0</em>, <em>N=5000</em>, <em>center_freq=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Example4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network" title="Potapov_Code.Time_Delay_Network.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Time_Delay_Network.Time_Delay_Network</span></code></a></p>
<p>Two inputs and two outputs, with free delay (i.e. not in a loop).
This corresponds to figures 9 and 10 in our paper.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Time_Delay_Network.Example5">
<em class="property">class </em><code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">Example5</code><span class="sig-paren">(</span><em>max_freq=50.0</em>, <em>max_linewidth=3.0</em>, <em>N=1000</em>, <em>center_freq=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Example5" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network" title="Potapov_Code.Time_Delay_Network.Time_Delay_Network"><code class="xref py py-class docutils literal"><span class="pre">Potapov_Code.Time_Delay_Network.Time_Delay_Network</span></code></a></p>
<p>Modified example 4, with analytic term.</p>
</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network">
<em class="property">class </em><code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">Time_Delay_Network</code><span class="sig-paren">(</span><em>max_freq=30.0</em>, <em>max_linewidth=1.0</em>, <em>N=1000</em>, <em>center_freq=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to contain the information of a passive linear network with time
delays.</p>
<dl class="attribute">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.max_freq">
<code class="descname">max_freq</code><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.max_freq" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [float]</em> &#8211; maximum height in the complex plane</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.max_linewidth">
<code class="descname">max_linewidth</code><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.max_linewidth" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [float]</em> &#8211; maximum width in the complex plane.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.N">
<code class="descname">N</code><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.N" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [int]</em> &#8211; number of points to use on the contour for finding</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">the roots/poles of the network.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.center_freq">
<code class="descname">center_freq</code><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.center_freq" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [float]</em> &#8211; how much to move the frame up or down</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">the complex plane.</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_Potapov_ABCD">
<code class="descname">get_Potapov_ABCD</code><span class="sig-paren">(</span><em>z=0.0</em>, <em>doubled=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_Potapov_ABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the ABCD matrices from the Time_Delay_Network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>z</strong> (<em>optional [complex number]</em>) &#8211; location where to estimate D.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A,B,C,D matrices.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_frequency_pertub_func_z">
<code class="descname">get_frequency_pertub_func_z</code><span class="sig-paren">(</span><em>use_ufuncify=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_frequency_pertub_func_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a function that can be used to perturb roots using
Newton&#8217;s method. This function has form <span class="math">\(-f(z) / f'(z)\)</span>
when the time delays are held fixed.</p>
<p>We give two ways to generate the perturbative function. One is
by directly plugging in numbers into a sympy expression and the
second is by using the ufuncify method to creative a wrapper for
the function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>use_ufuncify</strong> (<em>optional [boolean]</em>) &#8211; whether to use ufuncify</li>
<li><strong>not.</strong> (<em>or</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_minimizing_function_z">
<code class="descname">get_minimizing_function_z</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_minimizing_function_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimizing this function gives the adjusted roots.</p>
<p>Gives a function to minimize, its arguments are
<span class="math">\(x,y,Ts\)</span>. Also gives its derivative.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_outputs">
<code class="descname">get_outputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get some of the relevant outputs from the Potapov procedure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The original transfer function, the approximating generated
transfer function, the identified poles of the transfer function,
and the vectors representing the form of the Potapov factors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_symbolic_frequency_perturbation_z">
<code class="descname">get_symbolic_frequency_perturbation_z</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.get_symbolic_frequency_perturbation_z" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to prepare the symbolic expression T_denom_sym for further
computations. This expression represents the denominator in terms of
the various delays <span class="math">\(T_1,...,T_k\)</span> and the complex variable
<span class="math">\(z\)</span>.</p>
<p>The inputs should be <span class="math">\(z,(T_1+\Delta T_1,...,T_k+\Delta T_k)\)</span></p>
<p>This method treats the various delays as separate variables.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_T_Testing">
<code class="descname">make_T_Testing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_T_Testing" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the approximating transfer function using the identified
poles of the transfer function.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_commensurate_roots">
<code class="descname">make_commensurate_roots</code><span class="sig-paren">(</span><em>list_of_ranges=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_commensurate_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming the delays are commensurate, obtain all the roots within the
frequency ranges of interest. Sets self.roots a list of complex roots
in the desired frequency ranges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>list_of_ranges</strong> (<em>optional [list of 2-tuples]</em>) &#8211; list of frequency</li>
<li><strong>of interest in the form</strong> (<em>ranges</em>) &#8211; </li>
<li><strong>frequency, maximum frequency).</strong> (<em>(minimum</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_commensurate_vecs">
<code class="descname">make_commensurate_vecs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_commensurate_vecs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_roots">
<code class="descname">make_roots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the roots given the denominator of the transfer function.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_spatial_modes">
<code class="descname">make_spatial_modes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_spatial_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the spatial modes of the network.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_vecs">
<code class="descname">make_vecs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.make_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an ordered list of vectors representing the form of the
Potapov factors.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Time_Delay_Network.Time_Delay_Network.run_Potapov">
<code class="descname">run_Potapov</code><span class="sig-paren">(</span><em>commensurate_roots=False</em>, <em>filtering_roots=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.Time_Delay_Network.run_Potapov" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the entire Potapov procedure to find all important information.
The generated roots, vecs, approximated transfer function T_Testing,
and the spatial_modes are all stored in the class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>commensurate_roots</strong> (<em>optional[boolean]</em>) &#8211; which root-finding method</li>
<li><strong>use.</strong> (<em>to</em>) &#8211; </li>
<li><strong>filtering_roots</strong> (<em>optional[boolean]</em>) &#8211; makes sure the poles of the</li>
<li><strong>function all have negative real part. Drops ones that</strong> (<em>transfer</em>) &#8211; </li>
<li><strong>not.</strong> (<em>might</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Delay_Network.example6_pade">
<code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">example6_pade</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.example6_pade" title="Permalink to this definition">¶</a></dt>
<dd><p>This example is the same as example 3, but we return a Pade approximation
instead of a Potapov approximation. Instead of returnings roots, etc., we
return a different kind of function (see below).</p>
<p>This is used for figure 14 of our paper.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A matrix-valued function T(z,n). n is the order of the approximation
and z is the location of the function to be evaluated.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Delay_Network.plot3D">
<code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">plot3D</code><span class="sig-paren">(</span><em>f</em>, <em>points=2000</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.plot3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a color and hue plot in the complex plane for a given function</p>
<dl class="docutils">
<dt>Givens:</dt>
<dd>f (function): to plot
points(optional[int]): number of points to use per dimension</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Delay_Network.plot_all">
<code class="descclassname">Potapov_Code.Time_Delay_Network.</code><code class="descname">plot_all</code><span class="sig-paren">(</span><em>L</em>, <em>dx</em>, <em>labels</em>, <em>colors</em>, <em>lw</em>, <em>name</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Delay_Network.plot_all" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to plot the absolute value and phase of each component for a list
of matrix-valued functions in the complex plane along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; plot from 0 to L</li>
<li><strong>dx</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; distance between points</li>
<li><strong>labels</strong> (<em>list of str</em>) &#8211; labels to use</li>
<li><strong>colors</strong> (<em>list of srt</em>) &#8211; indicators of color for different curves</li>
<li><strong>lw</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; line width to use</li>
<li><strong>name</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; name of the file to save</li>
<li><strong>args</strong> (<em>*</em>) &#8211; A list of functions to plot</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Hamiltonian">
<span id="potapov-code-hamiltonian-module"></span><h2>Potapov_Code.Hamiltonian module<a class="headerlink" href="#module-Potapov_Code.Hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar 31 2015</p>
<p>&#64;author: gil
&#64;title: Hamiltonian.py</p>
<dl class="class">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin">
<em class="property">class </em><code class="descclassname">Potapov_Code.Hamiltonian.</code><code class="descname">Chi_nonlin</code><span class="sig-paren">(</span><em>delay_indices</em>, <em>start_nonlin</em>, <em>length_nonlin</em>, <em>refraction_index_func=&lt;function &lt;lambda&gt;&gt;</em>, <em>chi_order=3</em>, <em>chi_function=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to store the information in a particular nonlinear chi element.</p>
<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.delay_indices">
<code class="descname">delay_indices</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.delay_indices" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of indices</em> &#8211; indices of delays to use.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.start_nonlin">
<code class="descname">start_nonlin</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.start_nonlin" title="Permalink to this definition">¶</a></dt>
<dd><p><em>positive float or list of positive floats</em> &#8211; location of</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">nonlinear crystal with respect to each edge.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.length_nonlin">
<code class="descname">length_nonlin</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.length_nonlin" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; length of the nonlinear element.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.refraction_index_func">
<code class="descname">refraction_index_func</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.refraction_index_func" title="Permalink to this definition">¶</a></dt>
<dd><p><em>function</em> &#8211; the indices of refraction as a</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">function of the netural frequency :math:`/omega`.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.chi_order">
<code class="descname">chi_order</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.chi_order" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [int]</em> &#8211; order of nonlinearity</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.chi_function">
<code class="descname">chi_function</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.chi_function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [function]</em> &#8211; strength of nonlinearity.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.first">
<code class="descname">first</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.first" title="Permalink to this definition">¶</a></dt>
<dd><p><em>chi_order+1</em></p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Chi_nonlin.next">
<code class="descname">next</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Chi_nonlin.next" title="Permalink to this definition">¶</a></dt>
<dd><p><em>chi_order+1</em></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian">
<em class="property">class </em><code class="descclassname">Potapov_Code.Hamiltonian.</code><code class="descname">Hamiltonian</code><span class="sig-paren">(</span><em>roots</em>, <em>modes</em>, <em>delays</em>, <em>Omega=None</em>, <em>nonlin_coeff=1.0</em>, <em>polarizations=None</em>, <em>cross_sectional_area=1e-10</em>, <em>chi_nonlinearities=[]</em>, <em>using_qnet_symbols=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to create a sympy expression for the Hamiltonian of a network.</p>
<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.roots">
<code class="descname">roots</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.roots" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of complex numbers</em> &#8211; the poles of the transfer function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.omegas">
<code class="descname">omegas</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.omegas" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of floats</em> &#8211; the natural frequencies of the modes.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.modes">
<code class="descname">modes</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.modes" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of complex-valued column matrices</em> &#8211; modes of the network.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.delays">
<code class="descname">delays</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.delays" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list of floats</em> &#8211; the delays in the network.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.Omega">
<code class="descname">Omega</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.Omega" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [matrix]</em> &#8211; Quadratic Hamiltonian term for linear</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">dynamics.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.nonlin_coeff">
<code class="descname">nonlin_coeff</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.nonlin_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [float]</em> &#8211; overall scaling for the nonlinearities.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.polarizations">
<code class="descname">polarizations</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.polarizations" title="Permalink to this definition">¶</a></dt>
<dd><p><em>optional [list]</em> &#8211; the polarizations of the respective</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">modes. These should match the arguments in Chi_nonlin.chi_func.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.cross_sectional_area">
<code class="descname">cross_sectional_area</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.cross_sectional_area" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; area of beams, used to determines the</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">scaling for the various modes.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.chi_nonlinearities">
<code class="descname">chi_nonlinearities</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.chi_nonlinearities" title="Permalink to this definition">¶</a></dt>
<dd><p><em>lst</em> &#8211; a list of Chi_nonlin instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.TODO">
<code class="descname">TODO</code><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.TODO" title="Permalink to this definition">¶</a></dt>
<dd><p>Return L operator for QNET</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.Dagger">
<code class="descname">Dagger</code><span class="sig-paren">(</span><em>symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.Dagger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.E_field_weight">
<code class="descname">E_field_weight</code><span class="sig-paren">(</span><em>mode_index</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.E_field_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the weights for each field component <span class="math">\(E_i(n) = [\text{weight}] (a+a^\dagger)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mode_index</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The index of the mode.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><span class="math">\(sqrt[\hbar * \omega(n) / 2 V_eff(n) \epsilon]`\)</span>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">The weight in the equation above. It has form</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_Delta_delays">
<code class="descname">make_Delta_delays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_Delta_delays" title="Permalink to this definition">¶</a></dt>
<dd><p>Each different frequency will experience a different shift in delay
lengths due to all nonlinearities present.
We will store those shifts as a list of lists in the class.
This list is called Delta_delays.
The ith list will be the shifts in all the original delays for the ith
root (i.e. frequency).</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_E_field_weights">
<code class="descname">make_E_field_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_E_field_weights" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dictionary from mode index to the E-field weight.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_H">
<code class="descname">make_H</code><span class="sig-paren">(</span><em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a Hamiltonian combining the linear and nonlinear parts.</p>
<p>The term -1j*A carries the effective linear Hamiltonian, including the
decay term <span class="math">\(-\frac{i}{2} L^\dagger L\)</span>. However, this term does
not include material effects including dielectric and nonlinear terms.
It also does not include a term with contribution from the inputs.</p>
<p>If one wishes to include terms due to coherent input, one can impose a
linear Hamiltonian term consistent with the classical equations of
motion. This yields the usual term <span class="math">\(i(a \alpha^* - a^\dagger \alpha)\)</span>.</p>
<p>To obtain the form <span class="math">\(A = i \Omega - \frac{1}{2} C^\dagger C\)</span> with
<span class="math">\(Omega\)</span> Hermitian, we notice <span class="math">\(A\)</span> can be split into Hermitian
and anti-Hermitian parts. The anti-Hermitian part of A describes the
closed dynamics only and the Hermitian part corresponds to the decay
terms due to the coupling to the environment at the input/output ports.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Omega</strong> (<em>complex-valued matrix</em>) &#8211; </li>
<li><strong>= -1j*A        &lt;--- full dynamics</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Hamiltonian.Omega" title="Potapov_Code.Hamiltonian.Hamiltonian.Omega"><em>Omega</em></a>) &#8211; </li>
<li><strong>=</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Hamiltonian.Omega" title="Potapov_Code.Hamiltonian.Hamiltonian.Omega"><em>Omega</em></a>) &#8211; </li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; Cutoff for the significance of a particular term.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A symbolic expression for the full Hamiltonian.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_chi_nonlinearity">
<code class="descname">make_chi_nonlinearity</code><span class="sig-paren">(</span><em>delay_indices</em>, <em>start_nonlin</em>, <em>length_nonlin</em>, <em>refraction_index_func=&lt;function &lt;lambda&gt;&gt;</em>, <em>chi_order=3</em>, <em>chi_function=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_chi_nonlinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an instance of Chi_nonlin to Hamiltonian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>delay_indices</strong> (<em>int OR list/tuple of ints</em>) &#8211; the index representing the</li>
<li><strong>line along which the nonlinearity lies. If given a list/tuple</strong> (<em>delay</em>) &#8211; </li>
<li><strong>the nonlinearity interacts the N different modes.</strong> (<em>then</em>) &#8211; </li>
<li><strong>start_nonlin</strong> (<em>float OR list/tuple of floats</em>) &#8211; the beginning of the</li>
<li><strong>If a list/tuple then each nonlinearity begins at a</strong> (<em>nonlinearity.</em>) &#8211; </li>
<li><strong>time along its corresponding delay line.</strong> (<em>different</em>) &#8211; </li>
<li><strong>length_nonlin</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; duration of the nonlinearity in terms of</li>
<li><strong>length.</strong> (<em>Units in length</em>) &#8211; </li>
<li><strong>refraction_index_func</strong> (<em>function</em>) &#8211; the indices of refraction as a</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param function of the netural frequency <span class="math">\(/omega\)</span>.:
:param chi_order: order of the chi nonlinearity.
:type chi_order: optional [int]
:param chi_function: a function of 2*chi_order+2 parameters that
:type chi_function: function
:param returns the strenght of the interaction for given frequency:
:param combinations and polarizations. The first chi_order+1 parameters:
:param correspond to frequencies combined the the next chi_order+1 parameters:
:param correspond to the various polarizations.:
:param TODO: check units everywhere, including f versus omega = f / 2 pi.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_eq_motion">
<code class="descname">make_eq_motion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_eq_motion" title="Permalink to this definition">¶</a></dt>
<dd><p>Input is a tuple or list, output is a matrix vector.
This generates Hamilton&#8217;s equations of motion for a and a^H.
These equations are CLASSICAL equations of motion. This means
we replace the operators with c-numbers. The orde   r of the operators
will yield different results, so we assume the Hamiltonian is already
in the desired order (e.g. normally ordered).</p>
<p>These equations of motion will not show effects of squeezing. To do
this, we will need a full quantum picture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A function that yields the Hamiltonian equations of motion based on
the Hamiltonian given. The equations of motion map
<span class="math">\((t,a) \to v\)</span>. where math:<cite>t</cite> is a scalar corresponding to
time, <span class="math">\(a\)</span> is an array of inputs correpsonding to the internal
degrees of freedom, and <span class="math">\(v\)</span> is a complex-valued column matrix
describing the gradient.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_lin_H">
<code class="descname">make_lin_H</code><span class="sig-paren">(</span><em>Omega</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_lin_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a linear Hamiltonian based on Omega.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Omega</strong> (<em>complex-valued matrix</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A symbolic expression for the nonlinear Hamiltonian.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_H_from_chi">
<code class="descname">make_nonlin_H_from_chi</code><span class="sig-paren">(</span><em>chi</em>, <em>filtering_phase_weights=False</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_H_from_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nonlinear Hamiltonian based on nonlinear interaction terms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chi</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Potapov_Code.Hamiltonian.Chi_nonlin"><em>Chi_nonlin</em></a>) &#8211; nonlinearity to use</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; Cutoff for the significance of a particular term.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A symbolic expression for the nonlinear Hamiltonian.</p>
</td>
</tr>
</tbody>
</table>
<p>TODO:  Make separate dictionaries for values of chi_function,
for phase_matching_weights, and for producs of E_field_weights. filter
the keys before generating terms.</p>
<p>TODO: Make fast function for integrator; combine with make_f and make_f_lin</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_term_sympy">
<code class="descname">make_nonlin_term_sympy</code><span class="sig-paren">(</span><em>combination</em>, <em>pm_arr</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_nonlin_term_sympy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make symbolic nonlinear term using sympy.</p>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">combination</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span> <span class="n">pm_arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Hamiltonian</span><span class="o">.</span><span class="n">make_nonlin_term_sympy</span><span class="p">(</span><span class="n">combination</span><span class="p">,</span><span class="n">pm_arr</span><span class="p">)</span>
<span class="go">    a_1*Dagger(a_2)*Dagger(a_3)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>combination</strong> (<em>tuple/list of integers</em>) &#8211; indices of which terms to</li>
<li><strong>pm_arr</strong> (<em>include</em>) &#8211; creation and</li>
<li><strong>indicators for the respective terms in combination.</strong> (<em>annihilation</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">symbolic expression for the combination of creation and annihilation
operators.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_phase_matching_weights">
<code class="descname">make_phase_matching_weights</code><span class="sig-paren">(</span><em>weight_keys</em>, <em>chi</em>, <em>filtering_phase_weights=False</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_phase_matching_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a dict to store the weights for the selected components and the
creation/annihilation information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight_keys</strong> (<em>list of tuples</em>) &#8211; keys for weights to consider.</li>
<li><strong>key is a tuple consisting of two</strong> (<em>Each</em>) &#8211; </li>
<li><strong>components</strong> &#8211; the first is a tuple of the indices of modes and the</li>
<li><strong>is a tuple of +1 and -1.</strong> (<em>second</em>) &#8211; </li>
<li><strong>filtering_phase_weights</strong> (<em>optional[Boolean]</em>) &#8211; Whether or not to</li>
<li><strong>the phase_matching_weights by the size of their values. The</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#filter" title="(in Python v2.7)"><em>filter</em></a>) &#8211; </li>
<li><strong>for their absolute value is given by eps</strong> (<em>cutoff</em>) &#8211; </li>
<li><strong>eps</strong> (<em>optional [float]</em>) &#8211; Cutoff for filtering of weights.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dictionary of weights with values corresponding to the
phase matching coefficients.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.make_weight_keys">
<code class="descname">make_weight_keys</code><span class="sig-paren">(</span><em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.make_weight_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a list of keys for which various weights will be determined.
Each key is a tuple consisting of two
components: the first is a tuple of the indices of modes and the
second is a tuple of +1 and -1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chi</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Potapov_Code.Hamiltonian.Chi_nonlin"><em>Chi_nonlin</em></a>) &#8211; the nonlinearity for which the weight will be</li>
<li><strong>found.</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of keys of the type described.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.minimize_roots_z">
<code class="descname">minimize_roots_z</code><span class="sig-paren">(</span><em>func</em>, <em>dfunc</em>, <em>eps=1e-12</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.minimize_roots_z" title="Permalink to this definition">¶</a></dt>
<dd><p>One approach to perturb the roots is to use a function in <span class="math">\(x,y\)</span>
that becomes minimized at a zero. This is done here.</p>
<p>The result is an update to roots, omegas, and Delta_delays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dfuncs</strong> (<em>func,</em>) &#8211; Functions in x,y. The first becomes</li>
<li><strong>at a zero and the second is the gradient in x,y.</strong> (<em>minimized</em>) &#8211; </li>
<li><strong>functions are generated in</strong> (<em>These</em>) &#8211; </li>
<li><strong>Time_Delay_Network.get_minimizing_function_z.</strong> &#8211; </li>
<li><strong>eps</strong> (<em>optional [float]</em>) &#8211; desired precision for convergence.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.mode_volumes">
<code class="descname">mode_volumes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.mode_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the effective volume of each mode to normalize the field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the effective lengths of the various modes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.move_to_rotating_frame">
<code class="descname">move_to_rotating_frame</code><span class="sig-paren">(</span><em>freqs=0.0</em>, <em>include_time_terms=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.move_to_rotating_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves the Hamiltonian to a rotating frame</p>
<p>We apply a change of basis <span class="math">\(a_j \to a e^{- i \omega_j}\)</span> for
each mode <span class="math">\(a_j\)</span>. This method modifies the symbolic Hamiltonian,
so to use it the Hamiltonian sould already be constructed and stored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>freqs</strong> (<em>optional [real number or list/tuple]</em>) &#8211; Frequency or list</li>
<li><strong>frequencies to use to displace the Hamiltonian.</strong> (<em>of</em>) &#8211; </li>
<li><strong>include_time_terms</strong> (<em>optional [boolean]</em>) &#8211; If this is set to true,</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param we include the terms <span class="math">\(e^{- i \omega_j}\)</span> in the Hamiltonian:
:param resulting from a change of basis. This can be set to False if all:
:param such terms have already been eliminated (i.e. if the rotating wave:
:param approximation has been applied).:
:param ## TODO: replace the sine and cosine stuff with something nicer.
:param ## Maybe utilize the _get_real_imag_func method in Time_Delay_Network.:</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.normalize_modes">
<code class="descname">normalize_modes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.normalize_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the modes of Hamiltonian.</p>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.perturb_roots_z">
<code class="descname">perturb_roots_z</code><span class="sig-paren">(</span><em>perturb_func</em>, <em>eps=1e-12</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.perturb_roots_z" title="Permalink to this definition">¶</a></dt>
<dd><p>One approach to perturbing the roots is to use Newton&#8217;s method.
This is done here using a function perturb_func that corresponds to
<span class="math">\(-f(z) / f'(z)\)</span> when the time delays are held fixed.
The function perturb_func is generated in
get_frequency_pertub_func_z.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>perturb_func</strong> (<em>function</em>) &#8211; the Newton&#8217;s method function.</li>
<li><strong>eps</strong> (<em>optional [float]</em>) &#8211; desired precision for convergence</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Potapov_Code.Hamiltonian.Hamiltonian.phase_weight">
<code class="descname">phase_weight</code><span class="sig-paren">(</span><em>combination</em>, <em>pm_arr</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Hamiltonian.Hamiltonian.phase_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>The weight to give to each nonlinear term characterized by the given
combination and pm_arr.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>combination</strong> (<em>list/tuple of integers</em>) &#8211; which modes/roots to pick</li>
<li><strong>pm_arr</strong> (<em>list of +1 and -1</em>) &#8211; creation and annihilation of modes</li>
<li><strong>chi</strong> (<a class="reference internal" href="#Potapov_Code.Hamiltonian.Chi_nonlin" title="Potapov_Code.Hamiltonian.Chi_nonlin"><em>Chi_nonlin</em></a>) &#8211; the chi nonlinearity for which to compute</li>
<li><strong>phase coefficient.</strong> (<em>the</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The weight to add to the Hamiltonian</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Potapov">
<span id="potapov-code-potapov-module"></span><h2>Potapov_Code.Potapov module<a class="headerlink" href="#module-Potapov_Code.Potapov" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 13:59:30 2015</p>
<p>&#64;author: Gil Tabak
&#64;title: Potapov</p>
<p>The code in this file implements the procedure for finding Blaschke-Potapov
products to approximate given functions near poles.</p>
<p>Please see section 6.2 in our manuscript for details: <a class="reference external" href="http://arxiv.org/abs/1510.08942">http://arxiv.org/abs/1510.08942</a>
(to be published in EPJ QT).</p>
<dl class="function">
<dt id="Potapov_Code.Potapov.Potapov_prod">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">Potapov_prod</code><span class="sig-paren">(</span><em>z</em>, <em>poles</em>, <em>vecs</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.Potapov_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a transfer function T(z) that outputs numpy matrices for imaginary
<span class="math">\(z = i \omega\)</span> and the desired poles that characterize the modes.
Returns the Potapov product as a function approximating the original
transfer function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>complex number</em>) &#8211; value where product is evaluated</li>
<li><strong>poles</strong> (<em>list of complex numbers</em>) &#8211; The poles of the Potapov product.</li>
<li><strong>vecs</strong> (<em>list of complex-valued matrices</em>) &#8211; The eigenvectors corresponding to</li>
<li><strong>orthogonal projectors of the Potapov product.</strong> (<em>the</em>) &#8211; </li>
<li><strong>N</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Dimensionality of the the range.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Complex-valued matrix of size <span class="math">\(N \times N\)</span>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.estimate_D">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">estimate_D</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>C</em>, <em>T</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.estimate_D" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the scattering matrix S=D using the ABC matrices
the transfer function T at a frequency <span class="math">\(z = i \omega\)</span>.</p>
<p>Try to satisfy
<span class="math">\(T(z) = D + C(zI-A)^{-1}B\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A,B,C</strong> (<em>matrices</em>) &#8211; The A,B, and C matrices of the</li>
<li><strong>representation</strong> (<em>state-space</em>) &#8211; </li>
<li><strong>T</strong> (<em>matrix-valued function</em>) &#8211; The input/output function</li>
<li><strong>estimate</strong> (<em>to</em>) &#8211; </li>
<li><strong>z</strong> (<em>complex number</em>) &#8211; the location at which the scattering</li>
<li><strong>will be estimated</strong> (<em>matrix</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The estimated S=D scaterring matrix based on the value of
the function T and the ABC matrices.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.finite_transfer_function">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">finite_transfer_function</code><span class="sig-paren">(</span><em>U</em>, <em>eigenvectors</em>, <em>eigenvalues</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.finite_transfer_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a rational Blaschke-Potapov product of z with the given
eigenvalues and eigenvectors and constant unitary factor U.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>complex-valued matrix</em>) &#8211; A unitary matrix.</li>
<li><strong>eigenvectors</strong> (<em>list of complex-valued matrices</em>) &#8211; eigenvectors to use</li>
<li><strong>eigenvalues</strong> (<em>list of complex numebrs</em>) &#8211; eigenvalues to use</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A function that takes a complex number and returns the Potapov product
evaluated at that number.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_ABCD">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_ABCD</code><span class="sig-paren">(</span><em>val</em>, <em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_ABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the ABCD model of a single Potapov factor given some eigenvalue
and eigenvector.</p>
<p>The ABCD model can be used to obtain the dynamics of a linear system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> (<em>complex number</em>) &#8211; an eigenvalue</li>
<li><strong>vec</strong> (<em>complex-valued matrix</em>) &#8211; an eigenvector</li>
<li><strong>sym</strong> (<em>optiona[boolean]</em>) &#8211; Modify <span class="math">\(B\)</span> and <span class="math">\(C\)</span> so that <span class="math">\(B = C.H\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list [A,B,C,D] of four matrices representing the ABCD model.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_Potapov">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_Potapov</code><span class="sig-paren">(</span><em>T</em>, <em>poles</em>, <em>found_vecs</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_Potapov" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a transfer function T and some poles, generate the Blaschke-Potapov
product to reconstruct or approximate T, assuming that T can be represented
by the Blaschke-Potapov product with the given poles. Also match the values
of the functions at zero.</p>
<p>If T is a Blaschke-Potapov function and the the given poles are the only poles,
then T will be reconstructed.</p>
<p>In general, there is possibly an analytic term that is not captured by using
a Blaschke-Potapov approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>T</strong> (<em>matrix-valued function</em>) &#8211; A given meromorphic function</li>
<li><strong>poles</strong> (<em>a list of complex valued numbers</em>) &#8211; The given poles of T</li>
<li><strong>vecs</strong> (<em>list of complex-valued matrices</em>) &#8211; The eigenvectors corresponding to</li>
<li><strong>orthogonal projectors of the Potapov product.</strong> (<em>the</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A matrix-valued function equation to T at z=0 and approximating T
using a Potapov product generated by its poles and residues.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_Potapov_ABCD">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_Potapov_ABCD</code><span class="sig-paren">(</span><em>poles</em>, <em>vecs</em>, <em>T=None</em>, <em>z=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_Potapov_ABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the ABCD models for the different degrees of freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> (<em>a list of complex numbers</em>) &#8211; given eigenvalues</li>
<li><strong>vec</strong> (<em>a list of complex-valued matrices</em>) &#8211; given eigenvectors</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list [A,B,C,D] of four matrices representing the ABCD model.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.get_Potapov_vecs">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">get_Potapov_vecs</code><span class="sig-paren">(</span><em>T</em>, <em>poles</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.get_Potapov_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a transfer function T and some poles, compute the residues about the
poles and generate the eigenvectors to use for constructing the projectors
in the Blaschke-Potapov factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.normalize">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">normalize</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize a vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> (<em>complex-valued matrix</em>) &#8211; a vector</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The normalized vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.plot">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>L</em>, <em>dx</em>, <em>func</em>, <em>(i</em>, <em>j)</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>A nice function for plotting components of matrix-valued functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>L</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; length along which to plot</li>
<li><strong>dx</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; step length to take</li>
<li><strong>func</strong> (<em>function</em>) &#8211; complex matrix-valued function</li>
<li><strong>i,j</strong> (<em>tuple of ints</em>) &#8211; coordinate to plot</li>
<li><strong>args</strong> (<a class="reference internal" href="#module-Potapov_Code.functions" title="Potapov_Code.functions"><em>functions</em></a>) &#8211; Desired transformations on the inputs</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Potapov.prod">
<code class="descclassname">Potapov_Code.Potapov.</code><code class="descname">prod</code><span class="sig-paren">(</span><em>z</em>, <em>U</em>, <em>eigenvectors</em>, <em>eigenvalues</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Potapov.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Blaschke-Potapov product with the given eigenvalues and
eigenvectors and constant unitary factor U evaluated at z.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>complex number</em>) &#8211; where product is evaluated</li>
<li><strong>U</strong> (<em>complex-valued matrix</em>) &#8211; A unitary matrix</li>
<li><strong>eigenvectors</strong> (<em>list of complex-valued matrices</em>) &#8211; eigenvectors to use</li>
<li><strong>eigenvalues</strong> (<em>list of complex numebrs</em>) &#8211; eigenvalues to use</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A complex-valued matrix equal to the Potapov product evaluated at z.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Roots">
<span id="potapov-code-roots-module"></span><h2>Potapov_Code.Roots module<a class="headerlink" href="#module-Potapov_Code.Roots" title="Permalink to this headline">¶</a></h2>
<p>Created on Sat Feb 28 20:15:35 2015</p>
<p>&#64;author: gil
&#64;title: Rootfinder</p>
<p>Find the roots of a function f in the complex plane inside of a rectangular region.
We implement the method in the following paper:</p>
<blockquote>
<div>Delves, L. M., and J. N. Lyness. &#8220;A numerical method for locating the zeros of
an analytic function.&#8221; Mathematics of computation 21.100 (1967): 543-560.</div></blockquote>
<p>Alternative code using a similar method can be found here:</p>
<blockquote>
<div><a class="reference external" href="http://cpc.cs.qub.ac.uk/summaries/ADKW_v1_0.html">http://cpc.cs.qub.ac.uk/summaries/ADKW_v1_0.html</a></div></blockquote>
<p>The main idea is to compute contour integrals of functions of the form
<span class="math">\(z^k f'/f\)</span> around the contour, for integer values of k. Here <span class="math">\(f'\)</span> denotes the
derivative of f. The resulting values of the contour integrals are proportional
to <span class="math">\(\sum_i z_i^k\)</span>, where i is the index of the roots.</p>
<p>Throughout we denote <span class="math">\(f_{frac} = f'/f\)</span>.</p>
<p>I have also tried several optimizations and strategies for numerical stability.</p>
<dl class="function">
<dt id="Potapov_Code.Roots.Muller">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">Muller</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>x3</em>, <em>f</em>, <em>tol=1e-12</em>, <em>N=400</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.Muller" title="Permalink to this definition">¶</a></dt>
<dd><p>A method that works well for finding roots locally in the complex plane.
Uses three points for initial guess, x1,x2,x3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x1,x2,x3</strong> (<em>complex numbers</em>) &#8211; initial points for the algorithm</li>
<li><strong>f</strong> (<em>function</em>) &#8211; complex valued function for which to find roots</li>
<li><strong>tol</strong> (<em>optional[float]</em>) &#8211; tolerance</li>
<li><strong>N</strong> (<em>optional[int]</em>) &#8211; maximum number of iterations</li>
<li><strong>verbose</strong> (<em>optional[boolean]</em>) &#8211; print warnings</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">estimated root of the function f.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.combine">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">combine</code><span class="sig-paren">(</span><em>eps=1e-05</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>chain together several lists and purge redundancies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; tolerance for purging elements</li>
<li><strong>args</strong> (<em>lists</em>) &#8211; several lists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of combined elements.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.find_maxes">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">find_maxes</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.find_maxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of numbers, find the indices where local maxima happen.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>y</strong> (<em>list of floats</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of indices where maxima occur</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.find_roots">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">find_roots</code><span class="sig-paren">(</span><em>y_smooth</em>, <em>c</em>, <em>num_roots_to_find</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.find_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>given the values y_smooth, locations c, and the number to go up to,
find the roots using the polynomial trick.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>y_smooth</strong> (<em>list of complex numbers</em>) &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.get_boundary">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">get_boundary</code><span class="sig-paren">(</span><em>x_cent</em>, <em>y_cent</em>, <em>width</em>, <em>height</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.get_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a rectangle centered at x_cent,y_cent. Find points along this rectangle.
I use the convention that width/height make up half the dimensions of the rectangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_cent,y_cent</strong> (<em>floats</em>) &#8211; the coordinates of the center of the rectangle</li>
<li><strong>width,height</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; The (half) width and height of the rectangle</li>
<li><strong>N</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of points to use along each edge.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of points along the edge of the rectangle in the complex plane.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.get_max">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">get_max</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.get_max" title="Permalink to this definition">¶</a></dt>
<dd><p>return the <span class="math">\(IQR + median\)</span> to determine a maximum permissible value to use
in the numerically safe function new_f_frac_safe.</p>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.get_roots_rect">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">get_roots_rect</code><span class="sig-paren">(</span><em>f</em>, <em>fp</em>, <em>x_cent</em>, <em>y_cent</em>, <em>width</em>, <em>height</em>, <em>N=10</em>, <em>outlier_coeff=100.0</em>, <em>max_steps=5</em>, <em>known_roots=[]</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.get_roots_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>I assume f is analytic with simple (i.e. order one) zeros.</p>
<p>TODO:
save values along edges if iterating to a smaller rectangle
extend to other kinds of functions, e.g. function with non-simple zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> (<em>function</em>) &#8211; the function for which the roots (i.e. zeros) will be found</li>
<li><strong>fp</strong> (<em>function</em>) &#8211; the derivative of f</li>
<li><strong>x_cent,y_cent</strong> (<em>floats</em>) &#8211; The center of the rectangle in the complex plane</li>
<li><strong>width,height</strong> (<em>floats</em>) &#8211; half the width and height of the rectangular region</li>
<li><strong>N</strong> (<em>optional[int]</em>) &#8211; Number of points to sample per edge</li>
<li><strong>outlier_coeff</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; multiplier for coefficient used when subtracting</li>
<li><strong>to improve numerical stability. See new_f_frac_safe.</strong> (<em>poles</em>) &#8211; </li>
<li><strong>max_step</strong> (<em>optional[int]</em>) &#8211; Number of iterations allowed for algorithm to</li>
<li><strong>on smaller rectangles</strong> (<em>repeat</em>) &#8211; </li>
<li><strong>roots</strong> (<em>known</em>) &#8211; Roots of f that are</li>
<li><strong>known.</strong> (<em>already</em>) &#8211; </li>
<li><strong>verbose</strong> (<em>optional[boolean]</em>) &#8211; print warnings</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of roots for the function f inside the rectangle determined by
the values x_cent,y_cent,width, and height.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.inside_boundary">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">inside_boundary</code><span class="sig-paren">(</span><em>roots_near_boundary</em>, <em>x_cent</em>, <em>y_cent</em>, <em>width</em>, <em>height</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.inside_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes roots and the specification of a rectangular region
returns the roots in the interior (and ON the boundary) of the region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roots_near_boundary</strong> (<em>list of complex numbers</em>) &#8211; roots near the boundary</li>
<li><strong>x_cent,y_cent</strong> (<em>floats</em>) &#8211; coordinates of the center of the region</li>
<li><strong>width,height</strong> (<em>floats</em>) &#8211; The (half) width of height of the rectangle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Roots in the interior and on the boundary of the rectangle</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.linspace">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">linspace</code><span class="sig-paren">(</span><em>c1</em>, <em>c2</em>, <em>num=50</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>make a linespace method for complex numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>c1,c2</strong> (<em>complex numbers</em>) &#8211; The two points along which to draw a line.</li>
<li><strong>num</strong> (<em>optional [int]</em>) &#8211; number of points along the line</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of num points starting at c1 and going to c2.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.new_f_frac">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">new_f_frac</code><span class="sig-paren">(</span><em>f_frac</em>, <em>z0</em>, <em>residues</em>, <em>roots</em>, <em>val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.new_f_frac" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions that evaluate the f_frac after some roots and their residues are subtracted.
This function does NOT check to see if there is division by zero of if the
values become too large.</p>
<p>We assume here that the poles are of order 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f_frac</strong> (<em>function</em>) &#8211; function for which roots will be subtracted</li>
<li><strong>z0</strong> (<em>complex number</em>) &#8211; point where new_f_frac is evaluated</li>
<li><strong>residues</strong> (<em>list of complex numbers</em>) &#8211; The corresponding residues to subtract</li>
<li><strong>roots</strong> (<em>list of complex numbers</em>) &#8211; The corresponding roots to subtract</li>
<li><strong>val</strong> (<em>optional[complex number]</em>) &#8211; We can impose a value f_frac(z0) if we wish.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The new value of f_frac(z0) once the chosen poles have been subtracted.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.new_f_frac_safe">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">new_f_frac_safe</code><span class="sig-paren">(</span><em>f_frac</em>, <em>z0</em>, <em>residues</em>, <em>roots</em>, <em>max_ok</em>, <em>val=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.new_f_frac_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions that evaluate the f_frac after some roots and their residues are subtracted.
The safe version checks for large values and division by zero.
If the value of f_frac(z0) is too large, subtracting the roots of f becomes
numerically unstable. In this case, we approximate the new function f_frac
by using the limit function.</p>
<p>We assume here that the poles are of order 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f_frac</strong> (<em>function</em>) &#8211; function for which roots will be subtracted</li>
<li><strong>z0</strong> (<em>complex number</em>) &#8211; point where new_f_frac is evaluated</li>
<li><strong>residues</strong> (<em>list of complex numbers</em>) &#8211; The corresponding residues to subtract</li>
<li><strong>roots</strong> (<em>list of complex numbers</em>) &#8211; The corresponding roots to subtract</li>
<li><strong>val</strong> (<em>optional[complex number]</em>) &#8211; We can impose a value f_frac(z0) if we wish.</li>
<li><strong>max_ok</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; </li>
<li><strong>verbose</strong> (<em>optional[boolean]</em>) &#8211; print warnings</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The new value of f_frac(z0) once the chosen poles have been subtracted.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.purge">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">purge</code><span class="sig-paren">(</span><em>lst</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.purge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of redundant elements in a list. There is a precision cutoff eps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lst</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; elements</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; precision cutoff</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list without redundant elements.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Roots.residues">
<code class="descclassname">Potapov_Code.Roots.</code><code class="descname">residues</code><span class="sig-paren">(</span><em>f_frac</em>, <em>roots</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Roots.residues" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the resides of <span class="math">\(f_{frac} = f'/f\)</span> given the location of some roots of f.
The roots of f are the poles of f_frac.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f_frac</strong> (<em>function</em>) &#8211; a complex</li>
<li><strong>roots</strong> (<em>a list of complex numbers</em>) &#8211; the roots of f; poles of f_frac</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of residues of f_frac.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Time_Sims">
<span id="potapov-code-time-sims-module"></span><h2>Potapov_Code.Time_Sims module<a class="headerlink" href="#module-Potapov_Code.Time_Sims" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 15:52:32 2015</p>
<p>&#64;author: gil
&#64;title: Time_Sims</p>
<dl class="function">
<dt id="Potapov_Code.Time_Sims.f">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">f</code><span class="sig-paren">(</span><em>t</em>, <em>y</em>, <em>A</em>, <em>B</em>, <em>force_func</em>, <em>forcing_port</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.plot_time">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">plot_time</code><span class="sig-paren">(</span><em>time</em>, <em>y</em>, <em>port_out</em>, <em>port_in</em>, <em>num=0</em>, <em>kind='FP'</em>, <em>format='pdf'</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.plot_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.stack_func_port">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">stack_func_port</code><span class="sig-paren">(</span><em>force_func</em>, <em>forcing_port</em>, <em>t</em>, <em>max_size</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.stack_func_port" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.test_stacking">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">test_stacking</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.test_stacking" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims.time_sim">
<code class="descclassname">Potapov_Code.Time_Sims.</code><code class="descname">time_sim</code><span class="sig-paren">(</span><em>Example, omega=0.0, t1=150, dt=0.05, freq=None, port_in=0, port_out=[0, 1], kind='FP'</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims.time_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>takes an example and simulates it up to t1 increments of dt.
freq indicates the maximum frequency where we look for modes
omega indicates the frequency of driving. omega = 0 is DC.
port_in and port_out are where the system is driven.</p>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.Time_Sims_nonlin">
<span id="potapov-code-time-sims-nonlin-module"></span><h2>Potapov_Code.Time_Sims_nonlin module<a class="headerlink" href="#module-Potapov_Code.Time_Sims_nonlin" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar 31 2015</p>
<p>&#64;author: gil
&#64;title: Time_Sims_Nonlin.py</p>
<dl class="function">
<dt id="Potapov_Code.Time_Sims_nonlin.make_f">
<code class="descclassname">Potapov_Code.Time_Sims_nonlin.</code><code class="descname">make_f</code><span class="sig-paren">(</span><em>eq_mot</em>, <em>B</em>, <em>a_in</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims_nonlin.make_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations of motion, including possibly nonlinear internal dynamics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>eq_mot</strong> (<em>function</em>) &#8211; The equations of motion, which map</td>
</tr>
</tbody>
</table>
<p>:param <span class="math">\(: `t\)</span> is a scalar corresponding to time,
:type <span class="math">\(: t,a
:param :math:`a\)</span> is an array of inputs correpsonding to the internal degrees:
:param of freedom, and <span class="math">\(v\)</span> is a complex-valued column matrix describing:
:param the gradient.:
:param B: The matrix multiplying the inputs to the system.
:type B: matrix
:param a_in: The inputs to the system
:type a_in: function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A function that maps <span class="math">\((t,a) \to f'(t,a)\)</span>, where t is a scalar (time), and
a is an array representing the state of the system.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims_nonlin.make_f_lin">
<code class="descclassname">Potapov_Code.Time_Sims_nonlin.</code><code class="descname">make_f_lin</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>a_in</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims_nonlin.make_f_lin" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear equations of motion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>A</strong> (<em>matrix</em>) &#8211; The matrix for the linear equations of motion:</td>
</tr>
</tbody>
</table>
<p>:param <span class="math">\(\frac{d}{dt}\begin{pmatrix} a \\ a^+ \end{pmatrix} = A \begin{pmatrix} a \\ a^+ \end{pmatrix}+ B \breve a_{in}:
:type :math:\)</span>frac{d}{dt}begin{pmatrix} a \ a^+ end{pmatrix} = A begin{pmatrix} a \ a^+ end{pmatrix}+ B breve a_{in}: t
:param B: The matrix multiplying the inputs to the system.
:type B: matrix
:param a_in: The inputs to the system <span class="math">\(\breve a\)</span>.
:type a_in: function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A function that maps <span class="math">\((t,a) \to f'(t,a)\)</span>, where t is a scalar (time), and
a is an array representing the state of the system.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.Time_Sims_nonlin.run_ODE">
<code class="descclassname">Potapov_Code.Time_Sims_nonlin.</code><code class="descname">run_ODE</code><span class="sig-paren">(</span><em>f</em>, <em>a_in</em>, <em>C</em>, <em>D</em>, <em>num_of_variables</em>, <em>T=10</em>, <em>dt=0.01</em>, <em>y0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.Time_Sims_nonlin.run_ODE" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the ODE for the given set of equations and record the outputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> (<em>function</em>) &#8211; Evolution of the system</li>
<li><strong>a_in</strong> (<em>function</em>) &#8211; inputs as a function of time</li>
<li><strong>C,D</strong> (<em>matrices</em>) &#8211; matrices to use to obtain output from system state and input</li>
<li><strong>num_of_variables</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of variables the system has</li>
<li><strong>T</strong> (<em>optional[positive float]</em>) &#8211; length of simulation</li>
<li><strong>dt</strong> (<em>optional[float]</em>) &#8211; time step used by the simulation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array Y of outputs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.functions">
<span id="potapov-code-functions-module"></span><h2>Potapov_Code.functions module<a class="headerlink" href="#module-Potapov_Code.functions" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Mar  2 13:59:30 2015</p>
<p>&#64;author: Gil Tabak
&#64;title: Potapov</p>
<p>Functions used by other files.</p>
<dl class="function">
<dt id="Potapov_Code.functions.Pade">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">Pade</code><span class="sig-paren">(</span><em>n</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.Pade" title="Permalink to this definition">¶</a></dt>
<dd><p>Pade pproximation of <span class="math">\(e^z\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>integer</em>) &#8211; order of approximation</li>
<li><strong>z</strong> (<em>complex number</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Value of Pade approximation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.Q">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">Q</code><span class="sig-paren">(</span><em>z</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerator of Pade approximation of <span class="math">\(e^z\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>integer</em>) &#8211; order of approximation</li>
<li><strong>z</strong> (<em>complex number</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Value of Numerator of Pade approximation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.der">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">der</code><span class="sig-paren">(</span><em>f</em>, <em>z</em>, <em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.der" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the derivative of the function f at z</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> (<em>function</em>) &#8211; the function to use.</li>
<li><strong>z</strong> (<em>complex number</em>) &#8211; point at which to evaluate derivative.</li>
<li><strong>eps</strong> (<em>optional[complex number]</em>) &#8211; number to perturb z to find derivative.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Derivative of f</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.double_up">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">double_up</code><span class="sig-paren">(</span><em>M1</em>, <em>M2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.double_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a given matrix M1 and an optional matrix M2 and generates a
doubled-up matrix to use for simulations when the doubled-up notation
is needed. i.e.</p>
<div class="math">
\[\begin{split}\begin{pmatrix}
    M_1 &amp;&amp; M_2
\end{pmatrix}
\to
\begin{pmatrix}
    M_1 &amp;&amp; M_2 \\
    M_2^\# &amp;&amp; M_1^\#
\end{pmatrix}\end{split}\]</div>
<p>In the case M2 == None, it becomes replaced by the zero matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M1</strong> &#8211; matrix to double-up</li>
<li><strong>M2</strong> &#8211; optional second matrix to double-up</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The doubled-up matrix.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.factorial">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">factorial</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the factorial of n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>integer</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">factorial of n</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.gcd_lst">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">gcd_lst</code><span class="sig-paren">(</span><em>lst</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.gcd_lst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.inner_product_of_two_modes">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">inner_product_of_two_modes</code><span class="sig-paren">(</span><em>root1</em>, <em>root2</em>, <em>v1</em>, <em>v2</em>, <em>delays</em>, <em>eps=1e-07</em>, <em>func=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.inner_product_of_two_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>This function integrates two spatial modes against each other
along the various delays of the system. Each delay follows a
node in the system.</p>
<p>The frequency is assumed to be the imaginary part of each root.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>root1,root2</strong> (<em>complex number</em>) &#8211; the two roots</li>
<li><strong>v1,v2</strong> (<em>column matrices</em>) &#8211; the amplitude of each mode at the</li>
<li><strong>nodes</strong> (<em>various</em>) &#8211; </li>
<li><strong>delays</strong> (<em>list of floats</em>) &#8211; The duration of each delay following</li>
<li><strong>node in the system</strong> (<em>each</em>) &#8211; </li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; cutoff for two frequencies being equal</li>
<li><strong>func</strong> (<em>optional[funciton]</em>) &#8211; used to transform the roots. Default</li>
<li><strong>is set to lambda z</strong> (<em>value</em>) &#8211; z.imag, meaning we take the frequency</li>
<li><strong>each mode.</strong> (<em>of</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The inner product of the two modes.
Sanity check: if root1==root2 and v1==v2, returns real value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.limit">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">limit</code><span class="sig-paren">(</span><em>f</em>, <em>z0</em>, <em>N=10</em>, <em>eps=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes possibly matrix-valued function f and its simple pole z0 and returns
limit_{z    o val} f(z). Estimates the value based on N surrounding
points at a distance eps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> (<em>function</em>) &#8211; the function for which the limit will be found.</li>
<li><strong>z0</strong> (<em>complex number</em>) &#8211; The value at which the limit is evaluated.</li>
<li><strong>N</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of points used in the estimate.</li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; distance from z0 at which estimating points are</li>
<li><strong>placed.</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The estimated value of limit_{z        o val} f(z).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.make_nonlinear_interaction">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">make_nonlinear_interaction</code><span class="sig-paren">(</span><em>natural_freqs</em>, <em>modes</em>, <em>delays</em>, <em>delay_indices</em>, <em>start_nonlin</em>, <em>length_nonlin</em>, <em>plus_or_minus_arr</em>, <em>indices_of_refraction=None</em>, <em>eps=1e-12</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.make_nonlinear_interaction" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes several (say M) natural_freqs and their corresponding modes,
as well as the (N) delay lengths of the network, and determines the term
we need to add to the Hamiltonian corresponding to the resulting
nonlinearity. We assume there is a crystal going from start_nonlin to
and has length length_nonlin. The plus_or_minus_arr is an array of
length m of 1 or -1 used to determined whether a mode corresponds to a
creation (1, a^dag) or annihilation (-1,a) operator. The corresponding
electric field integrated will be E^dag for 1 and E for -1.</p>
<p>The k-vectors are computed from the following formula:
k = omega / v_p = omega n(omega) / c.</p>
<p>If the indices of refraction n(omega_i) are given, we use them to compute
the phase-mismatch delta_k. Otherwise we assume they are all equal to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>natural_freqs</strong> (<em>list of complex numbers</em>) &#8211; The natural frequencies of the</li>
<li><strong>eigenmodes.</strong> (<em>various</em>) &#8211; </li>
<li><strong>modes</strong> (<em>list of column matrices</em>) &#8211; the amplitudes of the modes at</li>
<li><strong>nodes.</strong> (<em>various</em>) &#8211; </li>
<li><strong>delays</strong> (<em>list of floats</em>) &#8211; The duration of each delay following</li>
<li><strong>node in the system.</strong> (<em>each</em>) &#8211; </li>
<li><strong>delay_indices</strong> (<em>int OR list/tuple of ints</em>) &#8211; the index representing the</li>
<li><strong>line along which the nonlinearity lies. If given a list/tuple</strong> (<em>delay</em>) &#8211; </li>
<li><strong>the nonlinearity interacts the N different modes.</strong> (<em>then</em>) &#8211; </li>
<li><strong>start_nonlin</strong> (<em>float OR list/tuple of floats</em>) &#8211; the beginning of the</li>
<li><strong>If a list/tuple then each nonlinearity begins at a</strong> (<em>nonlinearity.</em>) &#8211; </li>
<li><strong>time along its corresponding delay line.</strong> (<em>different</em>) &#8211; </li>
<li><strong>length_nonlin</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; duration of the nonlinearity in terms of length.</li>
<li><strong>plus_or_minus_arr</strong> (<em>array of 1s and -1s</em>) &#8211; Creation/annihilation of</li>
<li><strong>photon in each of the given modes.</strong> (<em>a</em>) &#8211; </li>
<li><strong>indices_of_refraction</strong> (<em>float/int or list/tuple of float/int</em>) &#8211; the</li>
<li><strong>of refraction corresponding to the various modes. If float</strong> (<em>indices</em>) &#8211; </li>
<li><strong>int then all are the same.</strong> (<em>or</em>) &#8211; </li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; cutoff for two frequencies being equal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A matrix of normalized inner products representing the geometric
overlap of the various given modes in the system.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.make_normalized_inner_product_matrix">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">make_normalized_inner_product_matrix</code><span class="sig-paren">(</span><em>roots</em>, <em>modes</em>, <em>delays</em>, <em>eps=1e-12</em>, <em>func=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.make_normalized_inner_product_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of roots and a list of vectors representing the
electric field at each node of the corresponding nodes, compute
the normalized matrix representing the inner products among the
various modes.</p>
<p>TODO: add weights for different delays to account for geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roots</strong> (<em>list of complex numbers</em>) &#8211; The roots of the various eigenmodes</li>
<li><strong>modes</strong> (<em>list of column matrices</em>) &#8211; the amplitudes of the modes at</li>
<li><strong>nodes</strong> (<em>various</em>) &#8211; </li>
<li><strong>delays</strong> (<em>list of floats</em>) &#8211; The duration of each delay following</li>
<li><strong>node in the system</strong> (<em>each</em>) &#8211; </li>
<li><strong>eps</strong> (<em>optional[float]</em>) &#8211; cutoff for two frequencies being equal</li>
<li><strong>func</strong> (<em>optional[funciton]</em>) &#8211; used to transform the roots. Default</li>
<li><strong>is set to lambda z</strong> (<em>value</em>) &#8211; z.imag, meaning we take the frequency</li>
<li><strong>each mode.</strong> (<em>of</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A matrix of normalized inner products representing the geometric
overlap of the various given modes in the system.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.pade_approx">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">pade_approx</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.pade_approx" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerator coefficients of symmetric Pade approximation of math:<cite>e^z</cite> of order n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>integer</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Coefficients for Pade approximation numerator.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.pade_roots">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">pade_roots</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.pade_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract roots of Pade polynomial.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>integer</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Roots of Pade polynomial.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Potapov_Code.functions.spatial_modes">
<code class="descclassname">Potapov_Code.functions.</code><code class="descname">spatial_modes</code><span class="sig-paren">(</span><em>roots</em>, <em>M1</em>, <em>E</em>, <em>delays=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.functions.spatial_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the spetial mode profile at each node up to a constant.
If the delays are provided, the modes will be normalized using the delays.
Otherwise, the modes will not be normalized.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roots</strong> (<em>list of complex numbers</em>) &#8211; The eigenvalues of the system</li>
<li><strong>M1</strong> (<em>matrix</em>) &#8211; The connectivity matrix among internal nodes</li>
<li><strong>E</strong> (<em>matrix-valued function</em>) &#8211; Time-delay matrix</li>
<li><strong>delays</strong> (<em>optional[list of floats]</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of spatial eigenvectors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code.tests">
<span id="potapov-code-tests-module"></span><h2>Potapov_Code.tests module<a class="headerlink" href="#module-Potapov_Code.tests" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Potapov_Code.tests.test_altered_delay_pert">
<code class="descclassname">Potapov_Code.tests.</code><code class="descname">test_altered_delay_pert</code><span class="sig-paren">(</span><em>eps=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.tests.test_altered_delay_pert" title="Permalink to this definition">¶</a></dt>
<dd><p>We will have a method to shift the delays in the network before the
commensurate root analysis, which will be based on taking the average
Delta_delays that result from the nonlinearities over the different
frequencies. We test this here.</p>
<p>It also tests the corresponding perturbation in the frequencies.</p>
<p>We assume that the refraction_index_func and the input delays into
the Time_Delay_Network have been adjusted so that refraction_index_func
is close to zero in the desired frequency range.</p>
<p>There are several effects of the delays being different for different
modes. The most important one is an effective detuning for different
modes (as well as decay). There are other effects as well. The effective
mode volume will also change (this is taken into account in the
Hamitonian class). However, this is not taken into account in the Potapov
expansion because it becomes computationally difficult and the effect
will be small. This could be done in principle. The time delays in the
transfer function could be written as a function of frequency,
<span class="math">\(T = T(\omega)\)</span>.
The above function can be analytically continued to the complex plane.
Then the transfer function would be expressed
in terms of <span class="math">\(exp(-z T) = exp ( -z T (z))\)</span>.
Once this is done, the complex root-finding procedure can be applied.
The difficulty in using this approach is that the resulting functions no
longer have a periodic structure that we could identify when the delays
were commensurate.</p>
</dd></dl>

</div>
<div class="section" id="module-Potapov_Code">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-Potapov_Code" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Potapov_Code.contour_plot">
<code class="descclassname">Potapov_Code.</code><code class="descname">contour_plot</code><span class="sig-paren">(</span><em>Mat</em><span class="sig-paren">)</span><a class="headerlink" href="#Potapov_Code.contour_plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="includeme.html" class="btn btn-neutral" title="Readme"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Gil Tabak.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>